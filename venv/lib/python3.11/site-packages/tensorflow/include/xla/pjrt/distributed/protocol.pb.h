// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xla/pjrt/distributed/protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_xla_2fpjrt_2fdistributed_2fprotocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_xla_2fpjrt_2fdistributed_2fprotocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_xla_2fpjrt_2fdistributed_2fprotocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
namespace xla {
class ConnectRequest;
struct ConnectRequestDefaultTypeInternal;
extern ConnectRequestDefaultTypeInternal _ConnectRequest_default_instance_;
class ConnectResponse;
struct ConnectResponseDefaultTypeInternal;
extern ConnectResponseDefaultTypeInternal _ConnectResponse_default_instance_;
class DeviceProto;
struct DeviceProtoDefaultTypeInternal;
extern DeviceProtoDefaultTypeInternal _DeviceProto_default_instance_;
class EnumerateDevicesRequest;
struct EnumerateDevicesRequestDefaultTypeInternal;
extern EnumerateDevicesRequestDefaultTypeInternal _EnumerateDevicesRequest_default_instance_;
class EnumerateDevicesResponse;
struct EnumerateDevicesResponseDefaultTypeInternal;
extern EnumerateDevicesResponseDefaultTypeInternal _EnumerateDevicesResponse_default_instance_;
class GlobalTopologyProto;
struct GlobalTopologyProtoDefaultTypeInternal;
extern GlobalTopologyProtoDefaultTypeInternal _GlobalTopologyProto_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class KeyValueGetRequest;
struct KeyValueGetRequestDefaultTypeInternal;
extern KeyValueGetRequestDefaultTypeInternal _KeyValueGetRequest_default_instance_;
class KeyValueGetResponse;
struct KeyValueGetResponseDefaultTypeInternal;
extern KeyValueGetResponseDefaultTypeInternal _KeyValueGetResponse_default_instance_;
class KeyValueSetRequest;
struct KeyValueSetRequestDefaultTypeInternal;
extern KeyValueSetRequestDefaultTypeInternal _KeyValueSetRequest_default_instance_;
class KeyValueSetResponse;
struct KeyValueSetResponseDefaultTypeInternal;
extern KeyValueSetResponseDefaultTypeInternal _KeyValueSetResponse_default_instance_;
class LocalTopologyProto;
struct LocalTopologyProtoDefaultTypeInternal;
extern LocalTopologyProtoDefaultTypeInternal _LocalTopologyProto_default_instance_;
class ShutdownRequest;
struct ShutdownRequestDefaultTypeInternal;
extern ShutdownRequestDefaultTypeInternal _ShutdownRequest_default_instance_;
class ShutdownResponse;
struct ShutdownResponseDefaultTypeInternal;
extern ShutdownResponseDefaultTypeInternal _ShutdownResponse_default_instance_;
class WaitAtBarrierRequest;
struct WaitAtBarrierRequestDefaultTypeInternal;
extern WaitAtBarrierRequestDefaultTypeInternal _WaitAtBarrierRequest_default_instance_;
class WaitAtBarrierResponse;
struct WaitAtBarrierResponseDefaultTypeInternal;
extern WaitAtBarrierResponseDefaultTypeInternal _WaitAtBarrierResponse_default_instance_;
}  // namespace xla
PROTOBUF_NAMESPACE_OPEN
template<> ::xla::ConnectRequest* Arena::CreateMaybeMessage<::xla::ConnectRequest>(Arena*);
template<> ::xla::ConnectResponse* Arena::CreateMaybeMessage<::xla::ConnectResponse>(Arena*);
template<> ::xla::DeviceProto* Arena::CreateMaybeMessage<::xla::DeviceProto>(Arena*);
template<> ::xla::EnumerateDevicesRequest* Arena::CreateMaybeMessage<::xla::EnumerateDevicesRequest>(Arena*);
template<> ::xla::EnumerateDevicesResponse* Arena::CreateMaybeMessage<::xla::EnumerateDevicesResponse>(Arena*);
template<> ::xla::GlobalTopologyProto* Arena::CreateMaybeMessage<::xla::GlobalTopologyProto>(Arena*);
template<> ::xla::HeartbeatRequest* Arena::CreateMaybeMessage<::xla::HeartbeatRequest>(Arena*);
template<> ::xla::HeartbeatResponse* Arena::CreateMaybeMessage<::xla::HeartbeatResponse>(Arena*);
template<> ::xla::KeyValueGetRequest* Arena::CreateMaybeMessage<::xla::KeyValueGetRequest>(Arena*);
template<> ::xla::KeyValueGetResponse* Arena::CreateMaybeMessage<::xla::KeyValueGetResponse>(Arena*);
template<> ::xla::KeyValueSetRequest* Arena::CreateMaybeMessage<::xla::KeyValueSetRequest>(Arena*);
template<> ::xla::KeyValueSetResponse* Arena::CreateMaybeMessage<::xla::KeyValueSetResponse>(Arena*);
template<> ::xla::LocalTopologyProto* Arena::CreateMaybeMessage<::xla::LocalTopologyProto>(Arena*);
template<> ::xla::ShutdownRequest* Arena::CreateMaybeMessage<::xla::ShutdownRequest>(Arena*);
template<> ::xla::ShutdownResponse* Arena::CreateMaybeMessage<::xla::ShutdownResponse>(Arena*);
template<> ::xla::WaitAtBarrierRequest* Arena::CreateMaybeMessage<::xla::WaitAtBarrierRequest>(Arena*);
template<> ::xla::WaitAtBarrierResponse* Arena::CreateMaybeMessage<::xla::WaitAtBarrierResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xla {

// ===================================================================

class DeviceProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.DeviceProto) */ {
 public:
  inline DeviceProto() : DeviceProto(nullptr) {}
  ~DeviceProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceProto(const DeviceProto& from);
  DeviceProto(DeviceProto&& from) noexcept
    : DeviceProto() {
    *this = ::std::move(from);
  }

  inline DeviceProto& operator=(const DeviceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceProto& operator=(DeviceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceProto* internal_default_instance() {
    return reinterpret_cast<const DeviceProto*>(
               &_DeviceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceProto& a, DeviceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceProto& from) {
    DeviceProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.DeviceProto";
  }
  protected:
  explicit DeviceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kVendorFieldNumber = 3,
    kLocalDeviceOrdinalFieldNumber = 1,
    kGlobalDeviceIdFieldNumber = 4,
    kSliceIndexFieldNumber = 5,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string vendor = 3;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // int32 local_device_ordinal = 1;
  void clear_local_device_ordinal();
  int32_t local_device_ordinal() const;
  void set_local_device_ordinal(int32_t value);
  private:
  int32_t _internal_local_device_ordinal() const;
  void _internal_set_local_device_ordinal(int32_t value);
  public:

  // int32 global_device_id = 4;
  void clear_global_device_id();
  int32_t global_device_id() const;
  void set_global_device_id(int32_t value);
  private:
  int32_t _internal_global_device_id() const;
  void _internal_set_global_device_id(int32_t value);
  public:

  // int32 slice_index = 5;
  void clear_slice_index();
  int32_t slice_index() const;
  void set_slice_index(int32_t value);
  private:
  int32_t _internal_slice_index() const;
  void _internal_set_slice_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.DeviceProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    int32_t local_device_ordinal_;
    int32_t global_device_id_;
    int32_t slice_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class LocalTopologyProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.LocalTopologyProto) */ {
 public:
  inline LocalTopologyProto() : LocalTopologyProto(nullptr) {}
  ~LocalTopologyProto() override;
  explicit PROTOBUF_CONSTEXPR LocalTopologyProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTopologyProto(const LocalTopologyProto& from);
  LocalTopologyProto(LocalTopologyProto&& from) noexcept
    : LocalTopologyProto() {
    *this = ::std::move(from);
  }

  inline LocalTopologyProto& operator=(const LocalTopologyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTopologyProto& operator=(LocalTopologyProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTopologyProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTopologyProto* internal_default_instance() {
    return reinterpret_cast<const LocalTopologyProto*>(
               &_LocalTopologyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LocalTopologyProto& a, LocalTopologyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTopologyProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTopologyProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTopologyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTopologyProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTopologyProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalTopologyProto& from) {
    LocalTopologyProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTopologyProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.LocalTopologyProto";
  }
  protected:
  explicit LocalTopologyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 3,
    kBootIdFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // repeated .xla.DeviceProto devices = 3;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::xla::DeviceProto* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceProto >*
      mutable_devices();
  private:
  const ::xla::DeviceProto& _internal_devices(int index) const;
  ::xla::DeviceProto* _internal_add_devices();
  public:
  const ::xla::DeviceProto& devices(int index) const;
  ::xla::DeviceProto* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceProto >&
      devices() const;

  // string boot_id = 2;
  void clear_boot_id();
  const std::string& boot_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boot_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boot_id();
  PROTOBUF_NODISCARD std::string* release_boot_id();
  void set_allocated_boot_id(std::string* boot_id);
  private:
  const std::string& _internal_boot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boot_id(const std::string& value);
  std::string* _internal_mutable_boot_id();
  public:

  // int32 node_id = 1;
  void clear_node_id();
  int32_t node_id() const;
  void set_node_id(int32_t value);
  private:
  int32_t _internal_node_id() const;
  void _internal_set_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.LocalTopologyProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceProto > devices_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boot_id_;
    int32_t node_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class GlobalTopologyProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.GlobalTopologyProto) */ {
 public:
  inline GlobalTopologyProto() : GlobalTopologyProto(nullptr) {}
  ~GlobalTopologyProto() override;
  explicit PROTOBUF_CONSTEXPR GlobalTopologyProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalTopologyProto(const GlobalTopologyProto& from);
  GlobalTopologyProto(GlobalTopologyProto&& from) noexcept
    : GlobalTopologyProto() {
    *this = ::std::move(from);
  }

  inline GlobalTopologyProto& operator=(const GlobalTopologyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalTopologyProto& operator=(GlobalTopologyProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalTopologyProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalTopologyProto* internal_default_instance() {
    return reinterpret_cast<const GlobalTopologyProto*>(
               &_GlobalTopologyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GlobalTopologyProto& a, GlobalTopologyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalTopologyProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalTopologyProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalTopologyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalTopologyProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalTopologyProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalTopologyProto& from) {
    GlobalTopologyProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalTopologyProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.GlobalTopologyProto";
  }
  protected:
  explicit GlobalTopologyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .xla.LocalTopologyProto nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::xla::LocalTopologyProto* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LocalTopologyProto >*
      mutable_nodes();
  private:
  const ::xla::LocalTopologyProto& _internal_nodes(int index) const;
  ::xla::LocalTopologyProto* _internal_add_nodes();
  public:
  const ::xla::LocalTopologyProto& nodes(int index) const;
  ::xla::LocalTopologyProto* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LocalTopologyProto >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:xla.GlobalTopologyProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LocalTopologyProto > nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ConnectRequest) */ {
 public:
  inline ConnectRequest() : ConnectRequest(nullptr) {}
  ~ConnectRequest() override;
  explicit PROTOBUF_CONSTEXPR ConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectRequest(const ConnectRequest& from);
  ConnectRequest(ConnectRequest&& from) noexcept
    : ConnectRequest() {
    *this = ::std::move(from);
  }

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectRequest& operator=(ConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectRequest*>(
               &_ConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConnectRequest& a, ConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectRequest& from) {
    ConnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ConnectRequest";
  }
  protected:
  explicit ConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolVersionFieldNumber = 1,
    kTimeoutMillisecondsFieldNumber = 2,
    kClientIdFieldNumber = 4,
    kNodeIdFieldNumber = 3,
  };
  // int32 protocol_version = 1;
  void clear_protocol_version();
  int32_t protocol_version() const;
  void set_protocol_version(int32_t value);
  private:
  int32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(int32_t value);
  public:

  // int32 timeout_milliseconds = 2;
  void clear_timeout_milliseconds();
  int32_t timeout_milliseconds() const;
  void set_timeout_milliseconds(int32_t value);
  private:
  int32_t _internal_timeout_milliseconds() const;
  void _internal_set_timeout_milliseconds(int32_t value);
  public:

  // uint64 client_id = 4;
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // int32 node_id = 3;
  void clear_node_id();
  int32_t node_id() const;
  void set_node_id(int32_t value);
  private:
  int32_t _internal_node_id() const;
  void _internal_set_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t protocol_version_;
    int32_t timeout_milliseconds_;
    uint64_t client_id_;
    int32_t node_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ConnectResponse) */ {
 public:
  inline ConnectResponse() : ConnectResponse(nullptr) {}
  ~ConnectResponse() override;
  explicit PROTOBUF_CONSTEXPR ConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectResponse(const ConnectResponse& from);
  ConnectResponse(ConnectResponse&& from) noexcept
    : ConnectResponse() {
    *this = ::std::move(from);
  }

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectResponse& operator=(ConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectResponse*>(
               &_ConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnectResponse& a, ConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectResponse& from) {
    ConnectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ConnectResponse";
  }
  protected:
  explicit ConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class EnumerateDevicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.EnumerateDevicesRequest) */ {
 public:
  inline EnumerateDevicesRequest() : EnumerateDevicesRequest(nullptr) {}
  ~EnumerateDevicesRequest() override;
  explicit PROTOBUF_CONSTEXPR EnumerateDevicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnumerateDevicesRequest(const EnumerateDevicesRequest& from);
  EnumerateDevicesRequest(EnumerateDevicesRequest&& from) noexcept
    : EnumerateDevicesRequest() {
    *this = ::std::move(from);
  }

  inline EnumerateDevicesRequest& operator=(const EnumerateDevicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumerateDevicesRequest& operator=(EnumerateDevicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumerateDevicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumerateDevicesRequest* internal_default_instance() {
    return reinterpret_cast<const EnumerateDevicesRequest*>(
               &_EnumerateDevicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EnumerateDevicesRequest& a, EnumerateDevicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumerateDevicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumerateDevicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumerateDevicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnumerateDevicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnumerateDevicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnumerateDevicesRequest& from) {
    EnumerateDevicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumerateDevicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.EnumerateDevicesRequest";
  }
  protected:
  explicit EnumerateDevicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalTopologyFieldNumber = 3,
    kSessionIdFieldNumber = 1,
  };
  // .xla.LocalTopologyProto local_topology = 3;
  bool has_local_topology() const;
  private:
  bool _internal_has_local_topology() const;
  public:
  void clear_local_topology();
  const ::xla::LocalTopologyProto& local_topology() const;
  PROTOBUF_NODISCARD ::xla::LocalTopologyProto* release_local_topology();
  ::xla::LocalTopologyProto* mutable_local_topology();
  void set_allocated_local_topology(::xla::LocalTopologyProto* local_topology);
  private:
  const ::xla::LocalTopologyProto& _internal_local_topology() const;
  ::xla::LocalTopologyProto* _internal_mutable_local_topology();
  public:
  void unsafe_arena_set_allocated_local_topology(
      ::xla::LocalTopologyProto* local_topology);
  ::xla::LocalTopologyProto* unsafe_arena_release_local_topology();

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.EnumerateDevicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::LocalTopologyProto* local_topology_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class EnumerateDevicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.EnumerateDevicesResponse) */ {
 public:
  inline EnumerateDevicesResponse() : EnumerateDevicesResponse(nullptr) {}
  ~EnumerateDevicesResponse() override;
  explicit PROTOBUF_CONSTEXPR EnumerateDevicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnumerateDevicesResponse(const EnumerateDevicesResponse& from);
  EnumerateDevicesResponse(EnumerateDevicesResponse&& from) noexcept
    : EnumerateDevicesResponse() {
    *this = ::std::move(from);
  }

  inline EnumerateDevicesResponse& operator=(const EnumerateDevicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumerateDevicesResponse& operator=(EnumerateDevicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumerateDevicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumerateDevicesResponse* internal_default_instance() {
    return reinterpret_cast<const EnumerateDevicesResponse*>(
               &_EnumerateDevicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EnumerateDevicesResponse& a, EnumerateDevicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumerateDevicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumerateDevicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumerateDevicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnumerateDevicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnumerateDevicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnumerateDevicesResponse& from) {
    EnumerateDevicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumerateDevicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.EnumerateDevicesResponse";
  }
  protected:
  explicit EnumerateDevicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGlobalTopologyFieldNumber = 1,
  };
  // .xla.GlobalTopologyProto global_topology = 1;
  bool has_global_topology() const;
  private:
  bool _internal_has_global_topology() const;
  public:
  void clear_global_topology();
  const ::xla::GlobalTopologyProto& global_topology() const;
  PROTOBUF_NODISCARD ::xla::GlobalTopologyProto* release_global_topology();
  ::xla::GlobalTopologyProto* mutable_global_topology();
  void set_allocated_global_topology(::xla::GlobalTopologyProto* global_topology);
  private:
  const ::xla::GlobalTopologyProto& _internal_global_topology() const;
  ::xla::GlobalTopologyProto* _internal_mutable_global_topology();
  public:
  void unsafe_arena_set_allocated_global_topology(
      ::xla::GlobalTopologyProto* global_topology);
  ::xla::GlobalTopologyProto* unsafe_arena_release_global_topology();

  // @@protoc_insertion_point(class_scope:xla.EnumerateDevicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::GlobalTopologyProto* global_topology_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class KeyValueGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.KeyValueGetRequest) */ {
 public:
  inline KeyValueGetRequest() : KeyValueGetRequest(nullptr) {}
  ~KeyValueGetRequest() override;
  explicit PROTOBUF_CONSTEXPR KeyValueGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValueGetRequest(const KeyValueGetRequest& from);
  KeyValueGetRequest(KeyValueGetRequest&& from) noexcept
    : KeyValueGetRequest() {
    *this = ::std::move(from);
  }

  inline KeyValueGetRequest& operator=(const KeyValueGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueGetRequest& operator=(KeyValueGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValueGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValueGetRequest* internal_default_instance() {
    return reinterpret_cast<const KeyValueGetRequest*>(
               &_KeyValueGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(KeyValueGetRequest& a, KeyValueGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValueGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValueGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValueGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValueGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValueGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyValueGetRequest& from) {
    KeyValueGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.KeyValueGetRequest";
  }
  protected:
  explicit KeyValueGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kSessionIdFieldNumber = 1,
    kTimeoutMillisecondsFieldNumber = 3,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // int32 timeout_milliseconds = 3;
  void clear_timeout_milliseconds();
  int32_t timeout_milliseconds() const;
  void set_timeout_milliseconds(int32_t value);
  private:
  int32_t _internal_timeout_milliseconds() const;
  void _internal_set_timeout_milliseconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.KeyValueGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t session_id_;
    int32_t timeout_milliseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class KeyValueGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.KeyValueGetResponse) */ {
 public:
  inline KeyValueGetResponse() : KeyValueGetResponse(nullptr) {}
  ~KeyValueGetResponse() override;
  explicit PROTOBUF_CONSTEXPR KeyValueGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValueGetResponse(const KeyValueGetResponse& from);
  KeyValueGetResponse(KeyValueGetResponse&& from) noexcept
    : KeyValueGetResponse() {
    *this = ::std::move(from);
  }

  inline KeyValueGetResponse& operator=(const KeyValueGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueGetResponse& operator=(KeyValueGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValueGetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValueGetResponse* internal_default_instance() {
    return reinterpret_cast<const KeyValueGetResponse*>(
               &_KeyValueGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(KeyValueGetResponse& a, KeyValueGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValueGetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValueGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValueGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValueGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValueGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyValueGetResponse& from) {
    KeyValueGetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueGetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.KeyValueGetResponse";
  }
  protected:
  explicit KeyValueGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kFoundFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bool found = 1;
  void clear_found();
  bool found() const;
  void set_found(bool value);
  private:
  bool _internal_found() const;
  void _internal_set_found(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xla.KeyValueGetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    bool found_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class KeyValueSetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.KeyValueSetRequest) */ {
 public:
  inline KeyValueSetRequest() : KeyValueSetRequest(nullptr) {}
  ~KeyValueSetRequest() override;
  explicit PROTOBUF_CONSTEXPR KeyValueSetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValueSetRequest(const KeyValueSetRequest& from);
  KeyValueSetRequest(KeyValueSetRequest&& from) noexcept
    : KeyValueSetRequest() {
    *this = ::std::move(from);
  }

  inline KeyValueSetRequest& operator=(const KeyValueSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueSetRequest& operator=(KeyValueSetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValueSetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValueSetRequest* internal_default_instance() {
    return reinterpret_cast<const KeyValueSetRequest*>(
               &_KeyValueSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(KeyValueSetRequest& a, KeyValueSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValueSetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValueSetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValueSetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValueSetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValueSetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyValueSetRequest& from) {
    KeyValueSetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueSetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.KeyValueSetRequest";
  }
  protected:
  explicit KeyValueSetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kSessionIdFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.KeyValueSetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class KeyValueSetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xla.KeyValueSetResponse) */ {
 public:
  inline KeyValueSetResponse() : KeyValueSetResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR KeyValueSetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValueSetResponse(const KeyValueSetResponse& from);
  KeyValueSetResponse(KeyValueSetResponse&& from) noexcept
    : KeyValueSetResponse() {
    *this = ::std::move(from);
  }

  inline KeyValueSetResponse& operator=(const KeyValueSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueSetResponse& operator=(KeyValueSetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValueSetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValueSetResponse* internal_default_instance() {
    return reinterpret_cast<const KeyValueSetResponse*>(
               &_KeyValueSetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(KeyValueSetResponse& a, KeyValueSetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValueSetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValueSetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValueSetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValueSetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const KeyValueSetResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const KeyValueSetResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.KeyValueSetResponse";
  }
  protected:
  explicit KeyValueSetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xla.KeyValueSetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class WaitAtBarrierRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.WaitAtBarrierRequest) */ {
 public:
  inline WaitAtBarrierRequest() : WaitAtBarrierRequest(nullptr) {}
  ~WaitAtBarrierRequest() override;
  explicit PROTOBUF_CONSTEXPR WaitAtBarrierRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitAtBarrierRequest(const WaitAtBarrierRequest& from);
  WaitAtBarrierRequest(WaitAtBarrierRequest&& from) noexcept
    : WaitAtBarrierRequest() {
    *this = ::std::move(from);
  }

  inline WaitAtBarrierRequest& operator=(const WaitAtBarrierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitAtBarrierRequest& operator=(WaitAtBarrierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitAtBarrierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitAtBarrierRequest* internal_default_instance() {
    return reinterpret_cast<const WaitAtBarrierRequest*>(
               &_WaitAtBarrierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WaitAtBarrierRequest& a, WaitAtBarrierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitAtBarrierRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitAtBarrierRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitAtBarrierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitAtBarrierRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WaitAtBarrierRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WaitAtBarrierRequest& from) {
    WaitAtBarrierRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitAtBarrierRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.WaitAtBarrierRequest";
  }
  protected:
  explicit WaitAtBarrierRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBarrierIdFieldNumber = 2,
    kSessionIdFieldNumber = 1,
    kNodeIdFieldNumber = 3,
    kTimeoutMillisecondsFieldNumber = 4,
  };
  // bytes barrier_id = 2;
  void clear_barrier_id();
  const std::string& barrier_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_barrier_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_barrier_id();
  PROTOBUF_NODISCARD std::string* release_barrier_id();
  void set_allocated_barrier_id(std::string* barrier_id);
  private:
  const std::string& _internal_barrier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_barrier_id(const std::string& value);
  std::string* _internal_mutable_barrier_id();
  public:

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // int32 node_id = 3;
  void clear_node_id();
  int32_t node_id() const;
  void set_node_id(int32_t value);
  private:
  int32_t _internal_node_id() const;
  void _internal_set_node_id(int32_t value);
  public:

  // int32 timeout_milliseconds = 4;
  void clear_timeout_milliseconds();
  int32_t timeout_milliseconds() const;
  void set_timeout_milliseconds(int32_t value);
  private:
  int32_t _internal_timeout_milliseconds() const;
  void _internal_set_timeout_milliseconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.WaitAtBarrierRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr barrier_id_;
    uint64_t session_id_;
    int32_t node_id_;
    int32_t timeout_milliseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class WaitAtBarrierResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xla.WaitAtBarrierResponse) */ {
 public:
  inline WaitAtBarrierResponse() : WaitAtBarrierResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR WaitAtBarrierResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitAtBarrierResponse(const WaitAtBarrierResponse& from);
  WaitAtBarrierResponse(WaitAtBarrierResponse&& from) noexcept
    : WaitAtBarrierResponse() {
    *this = ::std::move(from);
  }

  inline WaitAtBarrierResponse& operator=(const WaitAtBarrierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitAtBarrierResponse& operator=(WaitAtBarrierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitAtBarrierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitAtBarrierResponse* internal_default_instance() {
    return reinterpret_cast<const WaitAtBarrierResponse*>(
               &_WaitAtBarrierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(WaitAtBarrierResponse& a, WaitAtBarrierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitAtBarrierResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitAtBarrierResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitAtBarrierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitAtBarrierResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WaitAtBarrierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WaitAtBarrierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.WaitAtBarrierResponse";
  }
  protected:
  explicit WaitAtBarrierResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xla.WaitAtBarrierResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatRequest& from) {
    HeartbeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // int32 node_id = 2;
  void clear_node_id();
  int32_t node_id() const;
  void set_node_id(int32_t value);
  private:
  int32_t _internal_node_id() const;
  void _internal_set_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t session_id_;
    int32_t node_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xla.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeartbeatResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeartbeatResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xla.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ShutdownRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ShutdownRequest) */ {
 public:
  inline ShutdownRequest() : ShutdownRequest(nullptr) {}
  ~ShutdownRequest() override;
  explicit PROTOBUF_CONSTEXPR ShutdownRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownRequest(const ShutdownRequest& from);
  ShutdownRequest(ShutdownRequest&& from) noexcept
    : ShutdownRequest() {
    *this = ::std::move(from);
  }

  inline ShutdownRequest& operator=(const ShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownRequest& operator=(ShutdownRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownRequest* internal_default_instance() {
    return reinterpret_cast<const ShutdownRequest*>(
               &_ShutdownRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ShutdownRequest& a, ShutdownRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShutdownRequest& from) {
    ShutdownRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ShutdownRequest";
  }
  protected:
  explicit ShutdownRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // int32 node_id = 2;
  void clear_node_id();
  int32_t node_id() const;
  void set_node_id(int32_t value);
  private:
  int32_t _internal_node_id() const;
  void _internal_set_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ShutdownRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t session_id_;
    int32_t node_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// -------------------------------------------------------------------

class ShutdownResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xla.ShutdownResponse) */ {
 public:
  inline ShutdownResponse() : ShutdownResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShutdownResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownResponse(const ShutdownResponse& from);
  ShutdownResponse(ShutdownResponse&& from) noexcept
    : ShutdownResponse() {
    *this = ::std::move(from);
  }

  inline ShutdownResponse& operator=(const ShutdownResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownResponse& operator=(ShutdownResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownResponse*>(
               &_ShutdownResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ShutdownResponse& a, ShutdownResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShutdownResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShutdownResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ShutdownResponse";
  }
  protected:
  explicit ShutdownResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xla.ShutdownResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_xla_2fpjrt_2fdistributed_2fprotocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceProto

// int32 local_device_ordinal = 1;
inline void DeviceProto::clear_local_device_ordinal() {
  _impl_.local_device_ordinal_ = 0;
}
inline int32_t DeviceProto::_internal_local_device_ordinal() const {
  return _impl_.local_device_ordinal_;
}
inline int32_t DeviceProto::local_device_ordinal() const {
  // @@protoc_insertion_point(field_get:xla.DeviceProto.local_device_ordinal)
  return _internal_local_device_ordinal();
}
inline void DeviceProto::_internal_set_local_device_ordinal(int32_t value) {
  
  _impl_.local_device_ordinal_ = value;
}
inline void DeviceProto::set_local_device_ordinal(int32_t value) {
  _internal_set_local_device_ordinal(value);
  // @@protoc_insertion_point(field_set:xla.DeviceProto.local_device_ordinal)
}

// string name = 2;
inline void DeviceProto::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeviceProto::name() const {
  // @@protoc_insertion_point(field_get:xla.DeviceProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceProto::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.DeviceProto.name)
}
inline std::string* DeviceProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:xla.DeviceProto.name)
  return _s;
}
inline const std::string& DeviceProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeviceProto::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceProto::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceProto::release_name() {
  // @@protoc_insertion_point(field_release:xla.DeviceProto.name)
  return _impl_.name_.Release();
}
inline void DeviceProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.DeviceProto.name)
}

// string vendor = 3;
inline void DeviceProto::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& DeviceProto::vendor() const {
  // @@protoc_insertion_point(field_get:xla.DeviceProto.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceProto::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.DeviceProto.vendor)
}
inline std::string* DeviceProto::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:xla.DeviceProto.vendor)
  return _s;
}
inline const std::string& DeviceProto::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void DeviceProto::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceProto::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceProto::release_vendor() {
  // @@protoc_insertion_point(field_release:xla.DeviceProto.vendor)
  return _impl_.vendor_.Release();
}
inline void DeviceProto::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.DeviceProto.vendor)
}

// int32 global_device_id = 4;
inline void DeviceProto::clear_global_device_id() {
  _impl_.global_device_id_ = 0;
}
inline int32_t DeviceProto::_internal_global_device_id() const {
  return _impl_.global_device_id_;
}
inline int32_t DeviceProto::global_device_id() const {
  // @@protoc_insertion_point(field_get:xla.DeviceProto.global_device_id)
  return _internal_global_device_id();
}
inline void DeviceProto::_internal_set_global_device_id(int32_t value) {
  
  _impl_.global_device_id_ = value;
}
inline void DeviceProto::set_global_device_id(int32_t value) {
  _internal_set_global_device_id(value);
  // @@protoc_insertion_point(field_set:xla.DeviceProto.global_device_id)
}

// int32 slice_index = 5;
inline void DeviceProto::clear_slice_index() {
  _impl_.slice_index_ = 0;
}
inline int32_t DeviceProto::_internal_slice_index() const {
  return _impl_.slice_index_;
}
inline int32_t DeviceProto::slice_index() const {
  // @@protoc_insertion_point(field_get:xla.DeviceProto.slice_index)
  return _internal_slice_index();
}
inline void DeviceProto::_internal_set_slice_index(int32_t value) {
  
  _impl_.slice_index_ = value;
}
inline void DeviceProto::set_slice_index(int32_t value) {
  _internal_set_slice_index(value);
  // @@protoc_insertion_point(field_set:xla.DeviceProto.slice_index)
}

// -------------------------------------------------------------------

// LocalTopologyProto

// int32 node_id = 1;
inline void LocalTopologyProto::clear_node_id() {
  _impl_.node_id_ = 0;
}
inline int32_t LocalTopologyProto::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int32_t LocalTopologyProto::node_id() const {
  // @@protoc_insertion_point(field_get:xla.LocalTopologyProto.node_id)
  return _internal_node_id();
}
inline void LocalTopologyProto::_internal_set_node_id(int32_t value) {
  
  _impl_.node_id_ = value;
}
inline void LocalTopologyProto::set_node_id(int32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:xla.LocalTopologyProto.node_id)
}

// string boot_id = 2;
inline void LocalTopologyProto::clear_boot_id() {
  _impl_.boot_id_.ClearToEmpty();
}
inline const std::string& LocalTopologyProto::boot_id() const {
  // @@protoc_insertion_point(field_get:xla.LocalTopologyProto.boot_id)
  return _internal_boot_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalTopologyProto::set_boot_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.boot_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.LocalTopologyProto.boot_id)
}
inline std::string* LocalTopologyProto::mutable_boot_id() {
  std::string* _s = _internal_mutable_boot_id();
  // @@protoc_insertion_point(field_mutable:xla.LocalTopologyProto.boot_id)
  return _s;
}
inline const std::string& LocalTopologyProto::_internal_boot_id() const {
  return _impl_.boot_id_.Get();
}
inline void LocalTopologyProto::_internal_set_boot_id(const std::string& value) {
  
  _impl_.boot_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalTopologyProto::_internal_mutable_boot_id() {
  
  return _impl_.boot_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalTopologyProto::release_boot_id() {
  // @@protoc_insertion_point(field_release:xla.LocalTopologyProto.boot_id)
  return _impl_.boot_id_.Release();
}
inline void LocalTopologyProto::set_allocated_boot_id(std::string* boot_id) {
  if (boot_id != nullptr) {
    
  } else {
    
  }
  _impl_.boot_id_.SetAllocated(boot_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boot_id_.IsDefault()) {
    _impl_.boot_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.LocalTopologyProto.boot_id)
}

// repeated .xla.DeviceProto devices = 3;
inline int LocalTopologyProto::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int LocalTopologyProto::devices_size() const {
  return _internal_devices_size();
}
inline void LocalTopologyProto::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::xla::DeviceProto* LocalTopologyProto::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:xla.LocalTopologyProto.devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceProto >*
LocalTopologyProto::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:xla.LocalTopologyProto.devices)
  return &_impl_.devices_;
}
inline const ::xla::DeviceProto& LocalTopologyProto::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::xla::DeviceProto& LocalTopologyProto::devices(int index) const {
  // @@protoc_insertion_point(field_get:xla.LocalTopologyProto.devices)
  return _internal_devices(index);
}
inline ::xla::DeviceProto* LocalTopologyProto::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::xla::DeviceProto* LocalTopologyProto::add_devices() {
  ::xla::DeviceProto* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:xla.LocalTopologyProto.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceProto >&
LocalTopologyProto::devices() const {
  // @@protoc_insertion_point(field_list:xla.LocalTopologyProto.devices)
  return _impl_.devices_;
}

// -------------------------------------------------------------------

// GlobalTopologyProto

// repeated .xla.LocalTopologyProto nodes = 1;
inline int GlobalTopologyProto::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int GlobalTopologyProto::nodes_size() const {
  return _internal_nodes_size();
}
inline void GlobalTopologyProto::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::xla::LocalTopologyProto* GlobalTopologyProto::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:xla.GlobalTopologyProto.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LocalTopologyProto >*
GlobalTopologyProto::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:xla.GlobalTopologyProto.nodes)
  return &_impl_.nodes_;
}
inline const ::xla::LocalTopologyProto& GlobalTopologyProto::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::xla::LocalTopologyProto& GlobalTopologyProto::nodes(int index) const {
  // @@protoc_insertion_point(field_get:xla.GlobalTopologyProto.nodes)
  return _internal_nodes(index);
}
inline ::xla::LocalTopologyProto* GlobalTopologyProto::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::xla::LocalTopologyProto* GlobalTopologyProto::add_nodes() {
  ::xla::LocalTopologyProto* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:xla.GlobalTopologyProto.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LocalTopologyProto >&
GlobalTopologyProto::nodes() const {
  // @@protoc_insertion_point(field_list:xla.GlobalTopologyProto.nodes)
  return _impl_.nodes_;
}

// -------------------------------------------------------------------

// ConnectRequest

// int32 protocol_version = 1;
inline void ConnectRequest::clear_protocol_version() {
  _impl_.protocol_version_ = 0;
}
inline int32_t ConnectRequest::_internal_protocol_version() const {
  return _impl_.protocol_version_;
}
inline int32_t ConnectRequest::protocol_version() const {
  // @@protoc_insertion_point(field_get:xla.ConnectRequest.protocol_version)
  return _internal_protocol_version();
}
inline void ConnectRequest::_internal_set_protocol_version(int32_t value) {
  
  _impl_.protocol_version_ = value;
}
inline void ConnectRequest::set_protocol_version(int32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:xla.ConnectRequest.protocol_version)
}

// int32 timeout_milliseconds = 2;
inline void ConnectRequest::clear_timeout_milliseconds() {
  _impl_.timeout_milliseconds_ = 0;
}
inline int32_t ConnectRequest::_internal_timeout_milliseconds() const {
  return _impl_.timeout_milliseconds_;
}
inline int32_t ConnectRequest::timeout_milliseconds() const {
  // @@protoc_insertion_point(field_get:xla.ConnectRequest.timeout_milliseconds)
  return _internal_timeout_milliseconds();
}
inline void ConnectRequest::_internal_set_timeout_milliseconds(int32_t value) {
  
  _impl_.timeout_milliseconds_ = value;
}
inline void ConnectRequest::set_timeout_milliseconds(int32_t value) {
  _internal_set_timeout_milliseconds(value);
  // @@protoc_insertion_point(field_set:xla.ConnectRequest.timeout_milliseconds)
}

// int32 node_id = 3;
inline void ConnectRequest::clear_node_id() {
  _impl_.node_id_ = 0;
}
inline int32_t ConnectRequest::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int32_t ConnectRequest::node_id() const {
  // @@protoc_insertion_point(field_get:xla.ConnectRequest.node_id)
  return _internal_node_id();
}
inline void ConnectRequest::_internal_set_node_id(int32_t value) {
  
  _impl_.node_id_ = value;
}
inline void ConnectRequest::set_node_id(int32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:xla.ConnectRequest.node_id)
}

// uint64 client_id = 4;
inline void ConnectRequest::clear_client_id() {
  _impl_.client_id_ = uint64_t{0u};
}
inline uint64_t ConnectRequest::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint64_t ConnectRequest::client_id() const {
  // @@protoc_insertion_point(field_get:xla.ConnectRequest.client_id)
  return _internal_client_id();
}
inline void ConnectRequest::_internal_set_client_id(uint64_t value) {
  
  _impl_.client_id_ = value;
}
inline void ConnectRequest::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:xla.ConnectRequest.client_id)
}

// -------------------------------------------------------------------

// ConnectResponse

// uint64 session_id = 1;
inline void ConnectResponse::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t ConnectResponse::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t ConnectResponse::session_id() const {
  // @@protoc_insertion_point(field_get:xla.ConnectResponse.session_id)
  return _internal_session_id();
}
inline void ConnectResponse::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void ConnectResponse::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:xla.ConnectResponse.session_id)
}

// -------------------------------------------------------------------

// EnumerateDevicesRequest

// uint64 session_id = 1;
inline void EnumerateDevicesRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t EnumerateDevicesRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t EnumerateDevicesRequest::session_id() const {
  // @@protoc_insertion_point(field_get:xla.EnumerateDevicesRequest.session_id)
  return _internal_session_id();
}
inline void EnumerateDevicesRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void EnumerateDevicesRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:xla.EnumerateDevicesRequest.session_id)
}

// .xla.LocalTopologyProto local_topology = 3;
inline bool EnumerateDevicesRequest::_internal_has_local_topology() const {
  return this != internal_default_instance() && _impl_.local_topology_ != nullptr;
}
inline bool EnumerateDevicesRequest::has_local_topology() const {
  return _internal_has_local_topology();
}
inline void EnumerateDevicesRequest::clear_local_topology() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_topology_ != nullptr) {
    delete _impl_.local_topology_;
  }
  _impl_.local_topology_ = nullptr;
}
inline const ::xla::LocalTopologyProto& EnumerateDevicesRequest::_internal_local_topology() const {
  const ::xla::LocalTopologyProto* p = _impl_.local_topology_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::LocalTopologyProto&>(
      ::xla::_LocalTopologyProto_default_instance_);
}
inline const ::xla::LocalTopologyProto& EnumerateDevicesRequest::local_topology() const {
  // @@protoc_insertion_point(field_get:xla.EnumerateDevicesRequest.local_topology)
  return _internal_local_topology();
}
inline void EnumerateDevicesRequest::unsafe_arena_set_allocated_local_topology(
    ::xla::LocalTopologyProto* local_topology) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_topology_);
  }
  _impl_.local_topology_ = local_topology;
  if (local_topology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.EnumerateDevicesRequest.local_topology)
}
inline ::xla::LocalTopologyProto* EnumerateDevicesRequest::release_local_topology() {
  
  ::xla::LocalTopologyProto* temp = _impl_.local_topology_;
  _impl_.local_topology_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::xla::LocalTopologyProto* EnumerateDevicesRequest::unsafe_arena_release_local_topology() {
  // @@protoc_insertion_point(field_release:xla.EnumerateDevicesRequest.local_topology)
  
  ::xla::LocalTopologyProto* temp = _impl_.local_topology_;
  _impl_.local_topology_ = nullptr;
  return temp;
}
inline ::xla::LocalTopologyProto* EnumerateDevicesRequest::_internal_mutable_local_topology() {
  
  if (_impl_.local_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::xla::LocalTopologyProto>(GetArenaForAllocation());
    _impl_.local_topology_ = p;
  }
  return _impl_.local_topology_;
}
inline ::xla::LocalTopologyProto* EnumerateDevicesRequest::mutable_local_topology() {
  ::xla::LocalTopologyProto* _msg = _internal_mutable_local_topology();
  // @@protoc_insertion_point(field_mutable:xla.EnumerateDevicesRequest.local_topology)
  return _msg;
}
inline void EnumerateDevicesRequest::set_allocated_local_topology(::xla::LocalTopologyProto* local_topology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_topology_;
  }
  if (local_topology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_topology);
    if (message_arena != submessage_arena) {
      local_topology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_topology, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_topology_ = local_topology;
  // @@protoc_insertion_point(field_set_allocated:xla.EnumerateDevicesRequest.local_topology)
}

// -------------------------------------------------------------------

// EnumerateDevicesResponse

// .xla.GlobalTopologyProto global_topology = 1;
inline bool EnumerateDevicesResponse::_internal_has_global_topology() const {
  return this != internal_default_instance() && _impl_.global_topology_ != nullptr;
}
inline bool EnumerateDevicesResponse::has_global_topology() const {
  return _internal_has_global_topology();
}
inline void EnumerateDevicesResponse::clear_global_topology() {
  if (GetArenaForAllocation() == nullptr && _impl_.global_topology_ != nullptr) {
    delete _impl_.global_topology_;
  }
  _impl_.global_topology_ = nullptr;
}
inline const ::xla::GlobalTopologyProto& EnumerateDevicesResponse::_internal_global_topology() const {
  const ::xla::GlobalTopologyProto* p = _impl_.global_topology_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::GlobalTopologyProto&>(
      ::xla::_GlobalTopologyProto_default_instance_);
}
inline const ::xla::GlobalTopologyProto& EnumerateDevicesResponse::global_topology() const {
  // @@protoc_insertion_point(field_get:xla.EnumerateDevicesResponse.global_topology)
  return _internal_global_topology();
}
inline void EnumerateDevicesResponse::unsafe_arena_set_allocated_global_topology(
    ::xla::GlobalTopologyProto* global_topology) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.global_topology_);
  }
  _impl_.global_topology_ = global_topology;
  if (global_topology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.EnumerateDevicesResponse.global_topology)
}
inline ::xla::GlobalTopologyProto* EnumerateDevicesResponse::release_global_topology() {
  
  ::xla::GlobalTopologyProto* temp = _impl_.global_topology_;
  _impl_.global_topology_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::xla::GlobalTopologyProto* EnumerateDevicesResponse::unsafe_arena_release_global_topology() {
  // @@protoc_insertion_point(field_release:xla.EnumerateDevicesResponse.global_topology)
  
  ::xla::GlobalTopologyProto* temp = _impl_.global_topology_;
  _impl_.global_topology_ = nullptr;
  return temp;
}
inline ::xla::GlobalTopologyProto* EnumerateDevicesResponse::_internal_mutable_global_topology() {
  
  if (_impl_.global_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::xla::GlobalTopologyProto>(GetArenaForAllocation());
    _impl_.global_topology_ = p;
  }
  return _impl_.global_topology_;
}
inline ::xla::GlobalTopologyProto* EnumerateDevicesResponse::mutable_global_topology() {
  ::xla::GlobalTopologyProto* _msg = _internal_mutable_global_topology();
  // @@protoc_insertion_point(field_mutable:xla.EnumerateDevicesResponse.global_topology)
  return _msg;
}
inline void EnumerateDevicesResponse::set_allocated_global_topology(::xla::GlobalTopologyProto* global_topology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.global_topology_;
  }
  if (global_topology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(global_topology);
    if (message_arena != submessage_arena) {
      global_topology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_topology, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.global_topology_ = global_topology;
  // @@protoc_insertion_point(field_set_allocated:xla.EnumerateDevicesResponse.global_topology)
}

// -------------------------------------------------------------------

// KeyValueGetRequest

// uint64 session_id = 1;
inline void KeyValueGetRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t KeyValueGetRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t KeyValueGetRequest::session_id() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueGetRequest.session_id)
  return _internal_session_id();
}
inline void KeyValueGetRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void KeyValueGetRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:xla.KeyValueGetRequest.session_id)
}

// bytes key = 2;
inline void KeyValueGetRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& KeyValueGetRequest::key() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueGetRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValueGetRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.KeyValueGetRequest.key)
}
inline std::string* KeyValueGetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:xla.KeyValueGetRequest.key)
  return _s;
}
inline const std::string& KeyValueGetRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void KeyValueGetRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValueGetRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValueGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:xla.KeyValueGetRequest.key)
  return _impl_.key_.Release();
}
inline void KeyValueGetRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.KeyValueGetRequest.key)
}

// int32 timeout_milliseconds = 3;
inline void KeyValueGetRequest::clear_timeout_milliseconds() {
  _impl_.timeout_milliseconds_ = 0;
}
inline int32_t KeyValueGetRequest::_internal_timeout_milliseconds() const {
  return _impl_.timeout_milliseconds_;
}
inline int32_t KeyValueGetRequest::timeout_milliseconds() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueGetRequest.timeout_milliseconds)
  return _internal_timeout_milliseconds();
}
inline void KeyValueGetRequest::_internal_set_timeout_milliseconds(int32_t value) {
  
  _impl_.timeout_milliseconds_ = value;
}
inline void KeyValueGetRequest::set_timeout_milliseconds(int32_t value) {
  _internal_set_timeout_milliseconds(value);
  // @@protoc_insertion_point(field_set:xla.KeyValueGetRequest.timeout_milliseconds)
}

// -------------------------------------------------------------------

// KeyValueGetResponse

// bool found = 1;
inline void KeyValueGetResponse::clear_found() {
  _impl_.found_ = false;
}
inline bool KeyValueGetResponse::_internal_found() const {
  return _impl_.found_;
}
inline bool KeyValueGetResponse::found() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueGetResponse.found)
  return _internal_found();
}
inline void KeyValueGetResponse::_internal_set_found(bool value) {
  
  _impl_.found_ = value;
}
inline void KeyValueGetResponse::set_found(bool value) {
  _internal_set_found(value);
  // @@protoc_insertion_point(field_set:xla.KeyValueGetResponse.found)
}

// bytes value = 2;
inline void KeyValueGetResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& KeyValueGetResponse::value() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueGetResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValueGetResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.KeyValueGetResponse.value)
}
inline std::string* KeyValueGetResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:xla.KeyValueGetResponse.value)
  return _s;
}
inline const std::string& KeyValueGetResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void KeyValueGetResponse::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValueGetResponse::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValueGetResponse::release_value() {
  // @@protoc_insertion_point(field_release:xla.KeyValueGetResponse.value)
  return _impl_.value_.Release();
}
inline void KeyValueGetResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.KeyValueGetResponse.value)
}

// -------------------------------------------------------------------

// KeyValueSetRequest

// uint64 session_id = 1;
inline void KeyValueSetRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t KeyValueSetRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t KeyValueSetRequest::session_id() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueSetRequest.session_id)
  return _internal_session_id();
}
inline void KeyValueSetRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void KeyValueSetRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:xla.KeyValueSetRequest.session_id)
}

// bytes key = 2;
inline void KeyValueSetRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& KeyValueSetRequest::key() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueSetRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValueSetRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.KeyValueSetRequest.key)
}
inline std::string* KeyValueSetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:xla.KeyValueSetRequest.key)
  return _s;
}
inline const std::string& KeyValueSetRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void KeyValueSetRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValueSetRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValueSetRequest::release_key() {
  // @@protoc_insertion_point(field_release:xla.KeyValueSetRequest.key)
  return _impl_.key_.Release();
}
inline void KeyValueSetRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.KeyValueSetRequest.key)
}

// bytes value = 3;
inline void KeyValueSetRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& KeyValueSetRequest::value() const {
  // @@protoc_insertion_point(field_get:xla.KeyValueSetRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValueSetRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.KeyValueSetRequest.value)
}
inline std::string* KeyValueSetRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:xla.KeyValueSetRequest.value)
  return _s;
}
inline const std::string& KeyValueSetRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void KeyValueSetRequest::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValueSetRequest::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValueSetRequest::release_value() {
  // @@protoc_insertion_point(field_release:xla.KeyValueSetRequest.value)
  return _impl_.value_.Release();
}
inline void KeyValueSetRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.KeyValueSetRequest.value)
}

// -------------------------------------------------------------------

// KeyValueSetResponse

// -------------------------------------------------------------------

// WaitAtBarrierRequest

// uint64 session_id = 1;
inline void WaitAtBarrierRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t WaitAtBarrierRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t WaitAtBarrierRequest::session_id() const {
  // @@protoc_insertion_point(field_get:xla.WaitAtBarrierRequest.session_id)
  return _internal_session_id();
}
inline void WaitAtBarrierRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void WaitAtBarrierRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:xla.WaitAtBarrierRequest.session_id)
}

// bytes barrier_id = 2;
inline void WaitAtBarrierRequest::clear_barrier_id() {
  _impl_.barrier_id_.ClearToEmpty();
}
inline const std::string& WaitAtBarrierRequest::barrier_id() const {
  // @@protoc_insertion_point(field_get:xla.WaitAtBarrierRequest.barrier_id)
  return _internal_barrier_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WaitAtBarrierRequest::set_barrier_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.barrier_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xla.WaitAtBarrierRequest.barrier_id)
}
inline std::string* WaitAtBarrierRequest::mutable_barrier_id() {
  std::string* _s = _internal_mutable_barrier_id();
  // @@protoc_insertion_point(field_mutable:xla.WaitAtBarrierRequest.barrier_id)
  return _s;
}
inline const std::string& WaitAtBarrierRequest::_internal_barrier_id() const {
  return _impl_.barrier_id_.Get();
}
inline void WaitAtBarrierRequest::_internal_set_barrier_id(const std::string& value) {
  
  _impl_.barrier_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WaitAtBarrierRequest::_internal_mutable_barrier_id() {
  
  return _impl_.barrier_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WaitAtBarrierRequest::release_barrier_id() {
  // @@protoc_insertion_point(field_release:xla.WaitAtBarrierRequest.barrier_id)
  return _impl_.barrier_id_.Release();
}
inline void WaitAtBarrierRequest::set_allocated_barrier_id(std::string* barrier_id) {
  if (barrier_id != nullptr) {
    
  } else {
    
  }
  _impl_.barrier_id_.SetAllocated(barrier_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.barrier_id_.IsDefault()) {
    _impl_.barrier_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.WaitAtBarrierRequest.barrier_id)
}

// int32 node_id = 3;
inline void WaitAtBarrierRequest::clear_node_id() {
  _impl_.node_id_ = 0;
}
inline int32_t WaitAtBarrierRequest::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int32_t WaitAtBarrierRequest::node_id() const {
  // @@protoc_insertion_point(field_get:xla.WaitAtBarrierRequest.node_id)
  return _internal_node_id();
}
inline void WaitAtBarrierRequest::_internal_set_node_id(int32_t value) {
  
  _impl_.node_id_ = value;
}
inline void WaitAtBarrierRequest::set_node_id(int32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:xla.WaitAtBarrierRequest.node_id)
}

// int32 timeout_milliseconds = 4;
inline void WaitAtBarrierRequest::clear_timeout_milliseconds() {
  _impl_.timeout_milliseconds_ = 0;
}
inline int32_t WaitAtBarrierRequest::_internal_timeout_milliseconds() const {
  return _impl_.timeout_milliseconds_;
}
inline int32_t WaitAtBarrierRequest::timeout_milliseconds() const {
  // @@protoc_insertion_point(field_get:xla.WaitAtBarrierRequest.timeout_milliseconds)
  return _internal_timeout_milliseconds();
}
inline void WaitAtBarrierRequest::_internal_set_timeout_milliseconds(int32_t value) {
  
  _impl_.timeout_milliseconds_ = value;
}
inline void WaitAtBarrierRequest::set_timeout_milliseconds(int32_t value) {
  _internal_set_timeout_milliseconds(value);
  // @@protoc_insertion_point(field_set:xla.WaitAtBarrierRequest.timeout_milliseconds)
}

// -------------------------------------------------------------------

// WaitAtBarrierResponse

// -------------------------------------------------------------------

// HeartbeatRequest

// uint64 session_id = 1;
inline void HeartbeatRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t HeartbeatRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t HeartbeatRequest::session_id() const {
  // @@protoc_insertion_point(field_get:xla.HeartbeatRequest.session_id)
  return _internal_session_id();
}
inline void HeartbeatRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void HeartbeatRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:xla.HeartbeatRequest.session_id)
}

// int32 node_id = 2;
inline void HeartbeatRequest::clear_node_id() {
  _impl_.node_id_ = 0;
}
inline int32_t HeartbeatRequest::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int32_t HeartbeatRequest::node_id() const {
  // @@protoc_insertion_point(field_get:xla.HeartbeatRequest.node_id)
  return _internal_node_id();
}
inline void HeartbeatRequest::_internal_set_node_id(int32_t value) {
  
  _impl_.node_id_ = value;
}
inline void HeartbeatRequest::set_node_id(int32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:xla.HeartbeatRequest.node_id)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// -------------------------------------------------------------------

// ShutdownRequest

// uint64 session_id = 1;
inline void ShutdownRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t ShutdownRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t ShutdownRequest::session_id() const {
  // @@protoc_insertion_point(field_get:xla.ShutdownRequest.session_id)
  return _internal_session_id();
}
inline void ShutdownRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void ShutdownRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:xla.ShutdownRequest.session_id)
}

// int32 node_id = 2;
inline void ShutdownRequest::clear_node_id() {
  _impl_.node_id_ = 0;
}
inline int32_t ShutdownRequest::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int32_t ShutdownRequest::node_id() const {
  // @@protoc_insertion_point(field_get:xla.ShutdownRequest.node_id)
  return _internal_node_id();
}
inline void ShutdownRequest::_internal_set_node_id(int32_t value) {
  
  _impl_.node_id_ = value;
}
inline void ShutdownRequest::set_node_id(int32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:xla.ShutdownRequest.node_id)
}

// -------------------------------------------------------------------

// ShutdownResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace xla

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_xla_2fpjrt_2fdistributed_2fprotocol_2eproto
