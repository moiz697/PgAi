/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ANNOTATEDEALLOCATIONPASS
#define GEN_PASS_DECL_BUFFERREUSEPASS
#define GEN_PASS_DECL_CONVERTDEALLOCATIONOPSTOLLVMPASS
#define GEN_PASS_DECL_DEALLOCATEPASS
#define GEN_PASS_DECL_DEALLOCATIONSIMPLIFICATIONPASS
#define GEN_PASS_DECL_DEALLOCATIONTOSCFPASS
#define GEN_PASS_DECL_SPLITALLOCTENSORSPASS
#define GEN_PASS_DECL_XLABUFFERARGREWRITEPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AnnotateDeallocationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ANNOTATEDEALLOCATIONPASS
#undef GEN_PASS_DECL_ANNOTATEDEALLOCATIONPASS
#endif // GEN_PASS_DECL_ANNOTATEDEALLOCATIONPASS
#ifdef GEN_PASS_DEF_ANNOTATEDEALLOCATIONPASS
namespace impl {

template <typename DerivedT>
class AnnotateDeallocationPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AnnotateDeallocationPassBase;

  AnnotateDeallocationPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateDeallocationPassBase(const AnnotateDeallocationPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocation-annotation");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocation-annotation"; }

  ::llvm::StringRef getDescription() const override { return "Annotate ops with deallocation debug information."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateDeallocationPass");
  }
  ::llvm::StringRef getName() const override { return "AnnotateDeallocationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateDeallocationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ANNOTATEDEALLOCATIONPASS
#endif // GEN_PASS_DEF_ANNOTATEDEALLOCATIONPASS

//===----------------------------------------------------------------------===//
// BufferReusePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BUFFERREUSEPASS
#undef GEN_PASS_DECL_BUFFERREUSEPASS
#endif // GEN_PASS_DECL_BUFFERREUSEPASS
#ifdef GEN_PASS_DEF_BUFFERREUSEPASS
namespace impl {

template <typename DerivedT>
class BufferReusePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BufferReusePassBase;

  BufferReusePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReusePassBase(const BufferReusePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return "Reuse buffers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReusePass");
  }
  ::llvm::StringRef getName() const override { return "BufferReusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReusePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BUFFERREUSEPASS
#endif // GEN_PASS_DEF_BUFFERREUSEPASS

//===----------------------------------------------------------------------===//
// ConvertDeallocationOpsToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTDEALLOCATIONOPSTOLLVMPASS
#undef GEN_PASS_DECL_CONVERTDEALLOCATIONOPSTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTDEALLOCATIONOPSTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTDEALLOCATIONOPSTOLLVMPASS
namespace impl {

template <typename DerivedT>
class ConvertDeallocationOpsToLLVMPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertDeallocationOpsToLLVMPassBase;

  ConvertDeallocationOpsToLLVMPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertDeallocationOpsToLLVMPassBase(const ConvertDeallocationOpsToLLVMPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-convert-deallocation-ops-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-convert-deallocation-ops-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert `deallocation` ops to LLVM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertDeallocationOpsToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertDeallocationOpsToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertDeallocationOpsToLLVMPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTDEALLOCATIONOPSTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTDEALLOCATIONOPSTOLLVMPASS

//===----------------------------------------------------------------------===//
// DeallocatePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DEALLOCATEPASS
#undef GEN_PASS_DECL_DEALLOCATEPASS
#endif // GEN_PASS_DECL_DEALLOCATEPASS
#ifdef GEN_PASS_DEF_DEALLOCATEPASS
namespace impl {

template <typename DerivedT>
class DeallocatePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = DeallocatePassBase;

  DeallocatePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeallocatePassBase(const DeallocatePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocate");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocate"; }

  ::llvm::StringRef getDescription() const override { return "Deallocate buffers by inserting `deallocation.retain` ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeallocatePass");
  }
  ::llvm::StringRef getName() const override { return "DeallocatePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::deallocation::DeallocationDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeallocatePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DEALLOCATEPASS
#endif // GEN_PASS_DEF_DEALLOCATEPASS

//===----------------------------------------------------------------------===//
// DeallocationSimplificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DEALLOCATIONSIMPLIFICATIONPASS
#undef GEN_PASS_DECL_DEALLOCATIONSIMPLIFICATIONPASS
#endif // GEN_PASS_DECL_DEALLOCATIONSIMPLIFICATIONPASS
#ifdef GEN_PASS_DEF_DEALLOCATIONSIMPLIFICATIONPASS
namespace impl {

template <typename DerivedT>
class DeallocationSimplificationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeallocationSimplificationPassBase;

  DeallocationSimplificationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeallocationSimplificationPassBase(const DeallocationSimplificationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocation-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocation-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies deallocation.retain ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeallocationSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "DeallocationSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::deallocation::DeallocationDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeallocationSimplificationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DEALLOCATIONSIMPLIFICATIONPASS
#endif // GEN_PASS_DEF_DEALLOCATIONSIMPLIFICATIONPASS

//===----------------------------------------------------------------------===//
// DeallocationToScfPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DEALLOCATIONTOSCFPASS
#undef GEN_PASS_DECL_DEALLOCATIONTOSCFPASS
#endif // GEN_PASS_DECL_DEALLOCATIONTOSCFPASS
#ifdef GEN_PASS_DEF_DEALLOCATIONTOSCFPASS
namespace impl {

template <typename DerivedT>
class DeallocationToScfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeallocationToScfPassBase;

  DeallocationToScfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeallocationToScfPassBase(const DeallocationToScfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocation-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocation-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lowers retain to scf."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeallocationToScfPass");
  }
  ::llvm::StringRef getName() const override { return "DeallocationToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::scf::SCFDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeallocationToScfPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DEALLOCATIONTOSCFPASS
#endif // GEN_PASS_DEF_DEALLOCATIONTOSCFPASS

//===----------------------------------------------------------------------===//
// SplitAllocTensorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPLITALLOCTENSORSPASS
#undef GEN_PASS_DECL_SPLITALLOCTENSORSPASS
#endif // GEN_PASS_DECL_SPLITALLOCTENSORSPASS
#ifdef GEN_PASS_DEF_SPLITALLOCTENSORSPASS
namespace impl {

template <typename DerivedT>
class SplitAllocTensorsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SplitAllocTensorsPassBase;

  SplitAllocTensorsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SplitAllocTensorsPassBase(const SplitAllocTensorsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-split-alloc-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-split-alloc-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Split bufferization.alloc_tensor ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitAllocTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "SplitAllocTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::bufferization::BufferizationDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitAllocTensorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPLITALLOCTENSORSPASS
#endif // GEN_PASS_DEF_SPLITALLOCTENSORSPASS

//===----------------------------------------------------------------------===//
// XlaBufferArgRewritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_XLABUFFERARGREWRITEPASS
#undef GEN_PASS_DECL_XLABUFFERARGREWRITEPASS
#endif // GEN_PASS_DECL_XLABUFFERARGREWRITEPASS
#ifdef GEN_PASS_DEF_XLABUFFERARGREWRITEPASS
namespace impl {

template <typename DerivedT>
class XlaBufferArgRewritePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = XlaBufferArgRewritePassBase;

  XlaBufferArgRewritePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  XlaBufferArgRewritePassBase(const XlaBufferArgRewritePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-xla-buffer-arg-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-xla-buffer-arg-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites XLA framework buffer arguments with alias information"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XlaBufferArgRewritePass");
  }
  ::llvm::StringRef getName() const override { return "XlaBufferArgRewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XlaBufferArgRewritePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_XLABUFFERARGREWRITEPASS
#endif // GEN_PASS_DEF_XLABUFFERARGREWRITEPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AnnotateDeallocationPass Registration
//===----------------------------------------------------------------------===//

inline void registerAnnotateDeallocationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocationAnnotationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAnnotateDeallocationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocationAnnotationPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferReusePass Registration
//===----------------------------------------------------------------------===//

inline void registerBufferReusePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createBufferReusePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBufferReusePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createBufferReusePass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertDeallocationOpsToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertDeallocationOpsToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createConvertDeallocationOpsToLLVM();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertDeallocationOpsToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createConvertDeallocationOpsToLLVM();
  });
}

//===----------------------------------------------------------------------===//
// DeallocatePass Registration
//===----------------------------------------------------------------------===//

inline void registerDeallocatePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocatePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDeallocatePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocatePass();
  });
}

//===----------------------------------------------------------------------===//
// DeallocationSimplificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerDeallocationSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocationSimplificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDeallocationSimplificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocationSimplificationPass();
  });
}

//===----------------------------------------------------------------------===//
// DeallocationToScfPass Registration
//===----------------------------------------------------------------------===//

inline void registerDeallocationToScfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocationToScfPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDeallocationToScfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createDeallocationToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// SplitAllocTensorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerSplitAllocTensorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createSplitAllocTensorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSplitAllocTensorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createSplitAllocTensorsPass();
  });
}

//===----------------------------------------------------------------------===//
// XlaBufferArgRewritePass Registration
//===----------------------------------------------------------------------===//

inline void registerXlaBufferArgRewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createXlaBufferArgRewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerXlaBufferArgRewritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::deallocation::createXlaBufferArgRewritePass();
  });
}

//===----------------------------------------------------------------------===//
// Deallocation Registration
//===----------------------------------------------------------------------===//

inline void registerDeallocationPasses() {
  registerAnnotateDeallocationPass();
  registerBufferReusePass();
  registerConvertDeallocationOpsToLLVMPass();
  registerDeallocatePass();
  registerDeallocationSimplificationPass();
  registerDeallocationToScfPass();
  registerSplitAllocTensorsPass();
  registerXlaBufferArgRewritePass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AnnotateDeallocationPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AnnotateDeallocationPassBase;

  AnnotateDeallocationPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateDeallocationPassBase(const AnnotateDeallocationPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocation-annotation");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocation-annotation"; }

  ::llvm::StringRef getDescription() const override { return "Annotate ops with deallocation debug information."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateDeallocationPass");
  }
  ::llvm::StringRef getName() const override { return "AnnotateDeallocationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateDeallocationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BufferReusePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BufferReusePassBase;

  BufferReusePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReusePassBase(const BufferReusePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return "Reuse buffers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReusePass");
  }
  ::llvm::StringRef getName() const override { return "BufferReusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReusePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertDeallocationOpsToLLVMPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertDeallocationOpsToLLVMPassBase;

  ConvertDeallocationOpsToLLVMPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertDeallocationOpsToLLVMPassBase(const ConvertDeallocationOpsToLLVMPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-convert-deallocation-ops-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-convert-deallocation-ops-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert `deallocation` ops to LLVM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertDeallocationOpsToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertDeallocationOpsToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertDeallocationOpsToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DeallocatePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = DeallocatePassBase;

  DeallocatePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeallocatePassBase(const DeallocatePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocate");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocate"; }

  ::llvm::StringRef getDescription() const override { return "Deallocate buffers by inserting `deallocation.retain` ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeallocatePass");
  }
  ::llvm::StringRef getName() const override { return "DeallocatePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::deallocation::DeallocationDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeallocatePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DeallocationSimplificationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeallocationSimplificationPassBase;

  DeallocationSimplificationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeallocationSimplificationPassBase(const DeallocationSimplificationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocation-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocation-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies deallocation.retain ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeallocationSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "DeallocationSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::deallocation::DeallocationDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeallocationSimplificationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DeallocationToScfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeallocationToScfPassBase;

  DeallocationToScfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeallocationToScfPassBase(const DeallocationToScfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-deallocation-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-deallocation-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lowers retain to scf."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeallocationToScfPass");
  }
  ::llvm::StringRef getName() const override { return "DeallocationToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::scf::SCFDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeallocationToScfPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SplitAllocTensorsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SplitAllocTensorsPassBase;

  SplitAllocTensorsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SplitAllocTensorsPassBase(const SplitAllocTensorsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-split-alloc-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-split-alloc-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Split bufferization.alloc_tensor ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitAllocTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "SplitAllocTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::bufferization::BufferizationDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitAllocTensorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class XlaBufferArgRewritePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = XlaBufferArgRewritePassBase;

  XlaBufferArgRewritePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  XlaBufferArgRewritePassBase(const XlaBufferArgRewritePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-xla-buffer-arg-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-xla-buffer-arg-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites XLA framework buffer arguments with alias information"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XlaBufferArgRewritePass");
  }
  ::llvm::StringRef getName() const override { return "XlaBufferArgRewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XlaBufferArgRewritePassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
