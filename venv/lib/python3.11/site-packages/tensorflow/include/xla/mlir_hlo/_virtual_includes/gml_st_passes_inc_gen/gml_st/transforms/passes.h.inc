/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ADDDEBUGINFOPASS
#define GEN_PASS_DECL_COLLAPSESHAPEPASS
#define GEN_PASS_DECL_COLLECTSTATSPASS
#define GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#define GEN_PASS_DECL_FUSIONOUTLININGPASS
#define GEN_PASS_DECL_FUSIONPLANNINGFORCPUPASS
#define GEN_PASS_DECL_INLINEFUSIONCLUSTERSPASS
#define GEN_PASS_DECL_LOWERVECTORSPASS
#define GEN_PASS_DECL_NAIVECOPYREMOVALPASS
#define GEN_PASS_DECL_OPTIMIZELINALGOPSPASS
#define GEN_PASS_DECL_PACKMATMULPASS
#define GEN_PASS_DECL_REMOVELABELPASS
#define GEN_PASS_DECL_REWRITEFORALLOPPASS
#define GEN_PASS_DECL_REWRITEFROMELEMENTSOPPASS
#define GEN_PASS_DECL_SCALARIZATIONPASS
#define GEN_PASS_DECL_TILEBYONEPASS
#define GEN_PASS_DECL_TILINGSOFTMAXPASS
#define GEN_PASS_DECL_TRANSFORMDOTFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMELEMENTWISEFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMMMT4DFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMPACKFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#define GEN_PASS_DECL_VECTORIZECOPYPASS
#define GEN_PASS_DECL_VECTORIZEFORCPUPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AddDebugInfoPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADDDEBUGINFOPASS
#undef GEN_PASS_DECL_ADDDEBUGINFOPASS
#endif // GEN_PASS_DECL_ADDDEBUGINFOPASS
#ifdef GEN_PASS_DEF_ADDDEBUGINFOPASS
namespace impl {

template <typename DerivedT>
class AddDebugInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugInfoPassBase;

  AddDebugInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugInfoPassBase(const AddDebugInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-info");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-info"; }

  ::llvm::StringRef getDescription() const override { return "Add debug info for the whole module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugInfoPass");
  }
  ::llvm::StringRef getName() const override { return "AddDebugInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugInfoPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADDDEBUGINFOPASS
#endif // GEN_PASS_DEF_ADDDEBUGINFOPASS

//===----------------------------------------------------------------------===//
// CollapseShapePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COLLAPSESHAPEPASS
struct CollapseShapePassOptions {
  int64_t retainTrailingDims = 0;
};
#undef GEN_PASS_DECL_COLLAPSESHAPEPASS
#endif // GEN_PASS_DECL_COLLAPSESHAPEPASS
#ifdef GEN_PASS_DEF_COLLAPSESHAPEPASS
namespace impl {

template <typename DerivedT>
class CollapseShapePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CollapseShapePassBase;

  CollapseShapePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseShapePassBase(const CollapseShapePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-collapse-shape");
  }
  ::llvm::StringRef getArgument() const override { return "gml-collapse-shape"; }

  ::llvm::StringRef getDescription() const override { return "Collapse dimensions of bcasts, reductions, and cwise ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseShapePass");
  }
  ::llvm::StringRef getName() const override { return "CollapseShapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseShapePassBase<DerivedT>)

  CollapseShapePassBase(const CollapseShapePassOptions &options) : CollapseShapePassBase() {
    retainTrailingDims = options.retainTrailingDims;
  }
protected:
  ::mlir::Pass::Option<int64_t> retainTrailingDims{*this, "retain-trailing-dims", ::llvm::cl::desc("Number of trailing dimensions that will not be collapsed."), ::llvm::cl::init(0)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COLLAPSESHAPEPASS
#endif // GEN_PASS_DEF_COLLAPSESHAPEPASS

//===----------------------------------------------------------------------===//
// CollectStatsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COLLECTSTATSPASS
#undef GEN_PASS_DECL_COLLECTSTATSPASS
#endif // GEN_PASS_DECL_COLLECTSTATSPASS
#ifdef GEN_PASS_DEF_COLLECTSTATSPASS
namespace impl {

template <typename DerivedT>
class CollectStatsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CollectStatsPassBase;

  CollectStatsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollectStatsPassBase(const CollectStatsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("collect-stats");
  }
  ::llvm::StringRef getArgument() const override { return "collect-stats"; }

  ::llvm::StringRef getDescription() const override { return "Print stats about tileable ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollectStatsPass");
  }
  ::llvm::StringRef getName() const override { return "CollectStatsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollectStatsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COLLECTSTATSPASS
#endif // GEN_PASS_DEF_COLLECTSTATSPASS

//===----------------------------------------------------------------------===//
// ComposeExtractInsertSlicePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#undef GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#endif // GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#ifdef GEN_PASS_DEF_COMPOSEEXTRACTINSERTSLICEPASS
namespace impl {

template <typename DerivedT>
class ComposeExtractInsertSlicePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ComposeExtractInsertSlicePassBase;

  ComposeExtractInsertSlicePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ComposeExtractInsertSlicePassBase(const ComposeExtractInsertSlicePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-compose-extract-insert-slice");
  }
  ::llvm::StringRef getArgument() const override { return "gml-compose-extract-insert-slice"; }

  ::llvm::StringRef getDescription() const override { return "Compose tensor.extract_slice/insert_slice ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ComposeExtractInsertSlicePass");
  }
  ::llvm::StringRef getName() const override { return "ComposeExtractInsertSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ComposeExtractInsertSlicePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COMPOSEEXTRACTINSERTSLICEPASS
#endif // GEN_PASS_DEF_COMPOSEEXTRACTINSERTSLICEPASS

//===----------------------------------------------------------------------===//
// FusionOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSIONOUTLININGPASS
#undef GEN_PASS_DECL_FUSIONOUTLININGPASS
#endif // GEN_PASS_DECL_FUSIONOUTLININGPASS
#ifdef GEN_PASS_DEF_FUSIONOUTLININGPASS
namespace impl {

template <typename DerivedT>
class FusionOutliningPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = FusionOutliningPassBase;

  FusionOutliningPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusionOutliningPassBase(const FusionOutliningPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-fusion-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "gml-fusion-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Pass to outline fusion regions into functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusionOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "FusionOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusionOutliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSIONOUTLININGPASS
#endif // GEN_PASS_DEF_FUSIONOUTLININGPASS

//===----------------------------------------------------------------------===//
// FusionPlanningForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSIONPLANNINGFORCPUPASS
struct FusionPlanningForCpuPassOptions {
  int64_t vectorSize = 8;
};
#undef GEN_PASS_DECL_FUSIONPLANNINGFORCPUPASS
#endif // GEN_PASS_DECL_FUSIONPLANNINGFORCPUPASS
#ifdef GEN_PASS_DEF_FUSIONPLANNINGFORCPUPASS
namespace impl {

template <typename DerivedT>
class FusionPlanningForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusionPlanningForCpuPassBase;

  FusionPlanningForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusionPlanningForCpuPassBase(const FusionPlanningForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-fusion-planning");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-fusion-planning"; }

  ::llvm::StringRef getDescription() const override { return "Create fusion clusters."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusionPlanningForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "FusionPlanningForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::gml_st::GmlStDialect>();

  registry.insert<::mlir::linalg::LinalgDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusionPlanningForCpuPassBase<DerivedT>)

  FusionPlanningForCpuPassBase(const FusionPlanningForCpuPassOptions &options) : FusionPlanningForCpuPassBase() {
    vectorSize = options.vectorSize;
  }
protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Tile size for the innermost dimension of `linalg.map`"), ::llvm::cl::init(8)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSIONPLANNINGFORCPUPASS
#endif // GEN_PASS_DEF_FUSIONPLANNINGFORCPUPASS

//===----------------------------------------------------------------------===//
// InlineFusionClustersPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_INLINEFUSIONCLUSTERSPASS
#undef GEN_PASS_DECL_INLINEFUSIONCLUSTERSPASS
#endif // GEN_PASS_DECL_INLINEFUSIONCLUSTERSPASS
#ifdef GEN_PASS_DEF_INLINEFUSIONCLUSTERSPASS
namespace impl {

template <typename DerivedT>
class InlineFusionClustersPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = InlineFusionClustersPassBase;

  InlineFusionClustersPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InlineFusionClustersPassBase(const InlineFusionClustersPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-inline-fusion-clusters");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-inline-fusion-clusters"; }

  ::llvm::StringRef getDescription() const override { return "Replaces all gml_st.fusion op with ops from the region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InlineFusionClustersPass");
  }
  ::llvm::StringRef getName() const override { return "InlineFusionClustersPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::gml_st::GmlStDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InlineFusionClustersPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_INLINEFUSIONCLUSTERSPASS
#endif // GEN_PASS_DEF_INLINEFUSIONCLUSTERSPASS

//===----------------------------------------------------------------------===//
// LowerVectorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERVECTORSPASS
struct LowerVectorsPassOptions {
  bool enableAVX2 = true;
  bool flatten = false;
};
#undef GEN_PASS_DECL_LOWERVECTORSPASS
#endif // GEN_PASS_DECL_LOWERVECTORSPASS
#ifdef GEN_PASS_DEF_LOWERVECTORSPASS
namespace impl {

template <typename DerivedT>
class LowerVectorsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerVectorsPassBase;

  LowerVectorsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerVectorsPassBase(const LowerVectorsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-vectors");
  }
  ::llvm::StringRef getArgument() const override { return "lower-vectors"; }

  ::llvm::StringRef getDescription() const override { return "Pass to lower vector operations progressively."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerVectorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerVectorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::affine::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerVectorsPassBase<DerivedT>)

  LowerVectorsPassBase(const LowerVectorsPassOptions &options) : LowerVectorsPassBase() {
    enableAVX2 = options.enableAVX2;
    flatten = options.flatten;
  }
protected:
  ::mlir::Pass::Option<bool> enableAVX2{*this, "enable-avx2", ::llvm::cl::desc("Enable specialized lowerings for AVX2."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> flatten{*this, "flatten", ::llvm::cl::desc("Flatten multiple small n-D vector transfers into a large 1-D transfer."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERVECTORSPASS
#endif // GEN_PASS_DEF_LOWERVECTORSPASS

//===----------------------------------------------------------------------===//
// NaiveCopyRemovalPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NAIVECOPYREMOVALPASS
#undef GEN_PASS_DECL_NAIVECOPYREMOVALPASS
#endif // GEN_PASS_DECL_NAIVECOPYREMOVALPASS
#ifdef GEN_PASS_DEF_NAIVECOPYREMOVALPASS
namespace impl {

template <typename DerivedT>
class NaiveCopyRemovalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = NaiveCopyRemovalPassBase;

  NaiveCopyRemovalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  NaiveCopyRemovalPassBase(const NaiveCopyRemovalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("naive-copy-removal");
  }
  ::llvm::StringRef getArgument() const override { return "naive-copy-removal"; }

  ::llvm::StringRef getDescription() const override { return "Pass to remove redundant `memref.copy` ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NaiveCopyRemovalPass");
  }
  ::llvm::StringRef getName() const override { return "NaiveCopyRemovalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NaiveCopyRemovalPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_NAIVECOPYREMOVALPASS
#endif // GEN_PASS_DEF_NAIVECOPYREMOVALPASS

//===----------------------------------------------------------------------===//
// OptimizeLinalgOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OPTIMIZELINALGOPSPASS
#undef GEN_PASS_DECL_OPTIMIZELINALGOPSPASS
#endif // GEN_PASS_DECL_OPTIMIZELINALGOPSPASS
#ifdef GEN_PASS_DEF_OPTIMIZELINALGOPSPASS
namespace impl {

template <typename DerivedT>
class OptimizeLinalgOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLinalgOpsPassBase;

  OptimizeLinalgOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLinalgOpsPassBase(const OptimizeLinalgOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-optimize-linalg-ops-pass");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-optimize-linalg-ops-pass"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalization patterns for linalg ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLinalgOpsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLinalgOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::linalg::LinalgDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLinalgOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OPTIMIZELINALGOPSPASS
#endif // GEN_PASS_DEF_OPTIMIZELINALGOPSPASS

//===----------------------------------------------------------------------===//
// PackMatmulPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PACKMATMULPASS
#undef GEN_PASS_DECL_PACKMATMULPASS
#endif // GEN_PASS_DECL_PACKMATMULPASS
#ifdef GEN_PASS_DEF_PACKMATMULPASS
namespace impl {

template <typename DerivedT>
class PackMatmulPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PackMatmulPassBase;

  PackMatmulPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PackMatmulPassBase(const PackMatmulPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-pack-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-pack-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Pack linalg.matmul as linalg.mmt4d"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PackMatmulPass");
  }
  ::llvm::StringRef getName() const override { return "PackMatmulPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PackMatmulPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PACKMATMULPASS
#endif // GEN_PASS_DEF_PACKMATMULPASS

//===----------------------------------------------------------------------===//
// RemoveLabelPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REMOVELABELPASS
#undef GEN_PASS_DECL_REMOVELABELPASS
#endif // GEN_PASS_DECL_REMOVELABELPASS
#ifdef GEN_PASS_DEF_REMOVELABELPASS
namespace impl {

template <typename DerivedT>
class RemoveLabelPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveLabelPassBase;

  RemoveLabelPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveLabelPassBase(const RemoveLabelPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("remove-label");
  }
  ::llvm::StringRef getArgument() const override { return "remove-label"; }

  ::llvm::StringRef getDescription() const override { return "Remove transformed labels from tiled ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveLabelPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveLabelPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveLabelPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REMOVELABELPASS
#endif // GEN_PASS_DEF_REMOVELABELPASS

//===----------------------------------------------------------------------===//
// RewriteForallOpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEFORALLOPPASS
#undef GEN_PASS_DECL_REWRITEFORALLOPPASS
#endif // GEN_PASS_DECL_REWRITEFORALLOPPASS
#ifdef GEN_PASS_DEF_REWRITEFORALLOPPASS
namespace impl {

template <typename DerivedT>
class RewriteForallOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteForallOpPassBase;

  RewriteForallOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteForallOpPassBase(const RewriteForallOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-rewrite-forall-ops");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-rewrite-forall-ops"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite scf.forall to scf.for."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteForallOpPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteForallOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteForallOpPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEFORALLOPPASS
#endif // GEN_PASS_DEF_REWRITEFORALLOPPASS

//===----------------------------------------------------------------------===//
// RewriteFromElementsOpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEFROMELEMENTSOPPASS
#undef GEN_PASS_DECL_REWRITEFROMELEMENTSOPPASS
#endif // GEN_PASS_DECL_REWRITEFROMELEMENTSOPPASS
#ifdef GEN_PASS_DEF_REWRITEFROMELEMENTSOPPASS
namespace impl {

template <typename DerivedT>
class RewriteFromElementsOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteFromElementsOpPassBase;

  RewriteFromElementsOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteFromElementsOpPassBase(const RewriteFromElementsOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-rewrite-from-elements-ops");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-rewrite-from-elements-ops"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite tensor.from_elements into tensor.insert."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteFromElementsOpPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteFromElementsOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteFromElementsOpPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEFROMELEMENTSOPPASS
#endif // GEN_PASS_DEF_REWRITEFROMELEMENTSOPPASS

//===----------------------------------------------------------------------===//
// ScalarizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SCALARIZATIONPASS
struct ScalarizationPassOptions {
  bool scalarizeAllThlo = true;
};
#undef GEN_PASS_DECL_SCALARIZATIONPASS
#endif // GEN_PASS_DECL_SCALARIZATIONPASS
#ifdef GEN_PASS_DEF_SCALARIZATIONPASS
namespace impl {

template <typename DerivedT>
class ScalarizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ScalarizationPassBase;

  ScalarizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ScalarizationPassBase(const ScalarizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("scalarize");
  }
  ::llvm::StringRef getArgument() const override { return "scalarize"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops on tensors with 1 element to scalar ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ScalarizationPass");
  }
  ::llvm::StringRef getName() const override { return "ScalarizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithDialect>();

  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ScalarizationPassBase<DerivedT>)

  ScalarizationPassBase(const ScalarizationPassOptions &options) : ScalarizationPassBase() {
    scalarizeAllThlo = options.scalarizeAllThlo;
  }
protected:
  ::mlir::Pass::Option<bool> scalarizeAllThlo{*this, "scalarize-all-thlo", ::llvm::cl::desc("Enable scalarization of thlo.concatenate/gather/scatter."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SCALARIZATIONPASS
#endif // GEN_PASS_DEF_SCALARIZATIONPASS

//===----------------------------------------------------------------------===//
// TileByOnePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TILEBYONEPASS
#undef GEN_PASS_DECL_TILEBYONEPASS
#endif // GEN_PASS_DECL_TILEBYONEPASS
#ifdef GEN_PASS_DEF_TILEBYONEPASS
namespace impl {

template <typename DerivedT>
class TileByOnePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TileByOnePassBase;

  TileByOnePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TileByOnePassBase(const TileByOnePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tile-by-one");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tile-by-one"; }

  ::llvm::StringRef getDescription() const override { return "Tile all tileable ops by size 1"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TileByOnePass");
  }
  ::llvm::StringRef getName() const override { return "TileByOnePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TileByOnePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TILEBYONEPASS
#endif // GEN_PASS_DEF_TILEBYONEPASS

//===----------------------------------------------------------------------===//
// TilingSoftmaxPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TILINGSOFTMAXPASS
struct TilingSoftmaxPassOptions {
  ::llvm::ArrayRef<int64_t> tileSizes;
};
#undef GEN_PASS_DECL_TILINGSOFTMAXPASS
#endif // GEN_PASS_DECL_TILINGSOFTMAXPASS
#ifdef GEN_PASS_DEF_TILINGSOFTMAXPASS
namespace impl {

template <typename DerivedT>
class TilingSoftmaxPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingSoftmaxPassBase;

  TilingSoftmaxPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingSoftmaxPassBase(const TilingSoftmaxPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-softmax");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-softmax"; }

  ::llvm::StringRef getDescription() const override { return "Match, tile, and fuse softmax implementations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingSoftmaxPass");
  }
  ::llvm::StringRef getName() const override { return "TilingSoftmaxPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingSoftmaxPassBase<DerivedT>)

  TilingSoftmaxPassBase(const TilingSoftmaxPassOptions &options) : TilingSoftmaxPassBase() {
    tileSizes = options.tileSizes;
  }
protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Right-aligned tile sizes. Do not tile possible remaining dimensions"), llvm::cl::ZeroOrMore};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TILINGSOFTMAXPASS
#endif // GEN_PASS_DEF_TILINGSOFTMAXPASS

//===----------------------------------------------------------------------===//
// TransformDotForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMDOTFORCPUPASS
#undef GEN_PASS_DECL_TRANSFORMDOTFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMDOTFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMDOTFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformDotForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformDotForCpuPassBase;

  TransformDotForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformDotForCpuPassBase(const TransformDotForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-dot");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-dot"; }

  ::llvm::StringRef getDescription() const override { return "Transform dot ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformDotForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformDotForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformDotForCpuPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMDOTFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMDOTFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformElementwiseForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMELEMENTWISEFORCPUPASS
struct TransformElementwiseForCpuPassOptions {
  int64_t vectorSize = 8;
  bool fuseDegenerateReshapes = false;
};
#undef GEN_PASS_DECL_TRANSFORMELEMENTWISEFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMELEMENTWISEFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMELEMENTWISEFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformElementwiseForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformElementwiseForCpuPassBase;

  TransformElementwiseForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformElementwiseForCpuPassBase(const TransformElementwiseForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-elementwise");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-elementwise"; }

  ::llvm::StringRef getDescription() const override { return "Transform elementwise ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformElementwiseForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformElementwiseForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformElementwiseForCpuPassBase<DerivedT>)

  TransformElementwiseForCpuPassBase(const TransformElementwiseForCpuPassOptions &options) : TransformElementwiseForCpuPassBase() {
    vectorSize = options.vectorSize;
    fuseDegenerateReshapes = options.fuseDegenerateReshapes;
  }
protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Vector size."), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<bool> fuseDegenerateReshapes{*this, "fuse-degenerate-reshapes", ::llvm::cl::desc("Fuse through degenerate tensor.expand/collapse_shape"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMELEMENTWISEFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMELEMENTWISEFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformMmt4DForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMMMT4DFORCPUPASS
#undef GEN_PASS_DECL_TRANSFORMMMT4DFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMMMT4DFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMMMT4DFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformMmt4DForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMmt4DForCpuPassBase;

  TransformMmt4DForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMmt4DForCpuPassBase(const TransformMmt4DForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-mmt4d");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-mmt4d"; }

  ::llvm::StringRef getDescription() const override { return "Transform linalg.mmt4d ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMmt4DForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMmt4DForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMmt4DForCpuPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMMMT4DFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMMMT4DFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformPackForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMPACKFORCPUPASS
#undef GEN_PASS_DECL_TRANSFORMPACKFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMPACKFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMPACKFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformPackForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformPackForCpuPassBase;

  TransformPackForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformPackForCpuPassBase(const TransformPackForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-pack");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-pack"; }

  ::llvm::StringRef getDescription() const override { return "Transform tensor.pack/unpack ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformPackForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformPackForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformPackForCpuPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMPACKFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMPACKFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformReduceForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
struct TransformReduceForCpuPassOptions {
  bool enableHeuristic = false;
  int64_t tileSize1D = 32;
  int64_t splitRatio1D = 8;
  int64_t parallelDimTileSize2D = 4;
  int64_t reductionDimTileSize2D = 4;
};
#undef GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMREDUCEFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformReduceForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformReduceForCpuPassBase;

  TransformReduceForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformReduceForCpuPassBase(const TransformReduceForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-reduce");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-reduce"; }

  ::llvm::StringRef getDescription() const override { return "Transform reduce ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformReduceForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformReduceForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformReduceForCpuPassBase<DerivedT>)

  TransformReduceForCpuPassBase(const TransformReduceForCpuPassOptions &options) : TransformReduceForCpuPassBase() {
    enableHeuristic = options.enableHeuristic;
    tileSize1D = options.tileSize1D;
    splitRatio1D = options.splitRatio1D;
    parallelDimTileSize2D = options.parallelDimTileSize2D;
    reductionDimTileSize2D = options.reductionDimTileSize2D;
  }
protected:
  ::mlir::Pass::Option<bool> enableHeuristic{*this, "enable_heuristic", ::llvm::cl::desc("Enable heuristic for tiling sizes. Currently only for 1D."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int64_t> tileSize1D{*this, "reduction-1d-tile-size", ::llvm::cl::desc("Tile size for a 1D reduction."), ::llvm::cl::init(32)};
  ::mlir::Pass::Option<int64_t> splitRatio1D{*this, "reduction-1d-split-ratio", ::llvm::cl::desc("Ratio used to split the reduction dimension, i.e. tiled reduce op `reduce(tensor<N>)` will be split into a composition of a  column reduction `reduce(tensor<N/splitRatio1D x splitRatio1D>)` and a row 1D reductionreduce(tensor<splitRatio1D>)`."), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<int64_t> parallelDimTileSize2D{*this, "reduction-2d-parallel-dim-tile-size", ::llvm::cl::desc("Tile size for the parallel dimension of a 2D reduction."), ::llvm::cl::init(4)};
  ::mlir::Pass::Option<int64_t> reductionDimTileSize2D{*this, "reduction-2d-reduction-dim-tile-size", ::llvm::cl::desc("Tile size for the reduction dimension of a 2D reduction."), ::llvm::cl::init(4)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMREDUCEFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMREDUCEFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformScatterForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#undef GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMSCATTERFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformScatterForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformScatterForCpuPassBase;

  TransformScatterForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformScatterForCpuPassBase(const TransformScatterForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-scatter");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-scatter"; }

  ::llvm::StringRef getDescription() const override { return "Transform scatter ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformScatterForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformScatterForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformScatterForCpuPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMSCATTERFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMSCATTERFORCPUPASS

//===----------------------------------------------------------------------===//
// VectorizeCopyPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORIZECOPYPASS
struct VectorizeCopyPassOptions {
  int64_t numElementsThreshold = 8;
};
#undef GEN_PASS_DECL_VECTORIZECOPYPASS
#endif // GEN_PASS_DECL_VECTORIZECOPYPASS
#ifdef GEN_PASS_DEF_VECTORIZECOPYPASS
namespace impl {

template <typename DerivedT>
class VectorizeCopyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeCopyPassBase;

  VectorizeCopyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeCopyPassBase(const VectorizeCopyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-copy");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-copy"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize `memref.copy`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeCopyPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeCopyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<scf::SCFDialect>();

  registry.insert<vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeCopyPassBase<DerivedT>)

  VectorizeCopyPassBase(const VectorizeCopyPassOptions &options) : VectorizeCopyPassBase() {
    numElementsThreshold = options.numElementsThreshold;
  }
protected:
  ::mlir::Pass::Option<int64_t> numElementsThreshold{*this, "num-elements-threshold", ::llvm::cl::desc("Max number of elements in src and dst memref for a copy to be vectorized."), ::llvm::cl::init(8)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VECTORIZECOPYPASS
#endif // GEN_PASS_DEF_VECTORIZECOPYPASS

//===----------------------------------------------------------------------===//
// VectorizeForCPUPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORIZEFORCPUPASS
struct VectorizeForCPUPassOptions {
  int64_t numElementsThreshold = 128;
};
#undef GEN_PASS_DECL_VECTORIZEFORCPUPASS
#endif // GEN_PASS_DECL_VECTORIZEFORCPUPASS
#ifdef GEN_PASS_DEF_VECTORIZEFORCPUPASS
namespace impl {

template <typename DerivedT>
class VectorizeForCPUPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeForCPUPassBase;

  VectorizeForCPUPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeForCPUPassBase(const VectorizeForCPUPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-for-cpu");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-for-cpu"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize gml_st.for loops that are tiled perfectly."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeForCPUPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeForCPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeForCPUPassBase<DerivedT>)

  VectorizeForCPUPassBase(const VectorizeForCPUPassOptions &options) : VectorizeForCPUPassBase() {
    numElementsThreshold = options.numElementsThreshold;
  }
protected:
  ::mlir::Pass::Option<int64_t> numElementsThreshold{*this, "num-elements-threshold", ::llvm::cl::desc("Number of elements max of the tensor operands in order for the op to be vectorized."), ::llvm::cl::init(128)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VECTORIZEFORCPUPASS
#endif // GEN_PASS_DEF_VECTORIZEFORCPUPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AddDebugInfoPass Registration
//===----------------------------------------------------------------------===//

inline void registerAddDebugInfoPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createAddDebugInfoPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAddDebugInfoPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createAddDebugInfoPass();
  });
}

//===----------------------------------------------------------------------===//
// CollapseShapePass Registration
//===----------------------------------------------------------------------===//

inline void registerCollapseShapePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createCollapseShapePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCollapseShapePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createCollapseShapePass();
  });
}

//===----------------------------------------------------------------------===//
// CollectStatsPass Registration
//===----------------------------------------------------------------------===//

inline void registerCollectStatsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createCollectStatsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCollectStatsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createCollectStatsPass();
  });
}

//===----------------------------------------------------------------------===//
// ComposeExtractInsertSlicePass Registration
//===----------------------------------------------------------------------===//

inline void registerComposeExtractInsertSlicePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createComposeExtractInsertSlicePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerComposeExtractInsertSlicePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createComposeExtractInsertSlicePass();
  });
}

//===----------------------------------------------------------------------===//
// FusionOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerFusionOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFusionOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFusionOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFusionOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// FusionPlanningForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerFusionPlanningForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFusionPlanningForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFusionPlanningForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFusionPlanningForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// InlineFusionClustersPass Registration
//===----------------------------------------------------------------------===//

inline void registerInlineFusionClustersPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createInlineFusionClustersPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerInlineFusionClustersPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createInlineFusionClustersPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerVectorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerVectorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createLowerVectorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerVectorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createLowerVectorsPass();
  });
}

//===----------------------------------------------------------------------===//
// NaiveCopyRemovalPass Registration
//===----------------------------------------------------------------------===//

inline void registerNaiveCopyRemovalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createNaiveCopyRemovalPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNaiveCopyRemovalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createNaiveCopyRemovalPass();
  });
}

//===----------------------------------------------------------------------===//
// OptimizeLinalgOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizeLinalgOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createOptimizeLinalgOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOptimizeLinalgOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createOptimizeLinalgOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// PackMatmulPass Registration
//===----------------------------------------------------------------------===//

inline void registerPackMatmulPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createPackMatmulPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPackMatmulPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createPackMatmulPass();
  });
}

//===----------------------------------------------------------------------===//
// RemoveLabelPass Registration
//===----------------------------------------------------------------------===//

inline void registerRemoveLabelPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRemoveLabelPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRemoveLabelPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRemoveLabelPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteForallOpPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteForallOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRewriteForallOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteForallOpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRewriteForallOpPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteFromElementsOpPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteFromElementsOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRewriteFromElementsOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteFromElementsOpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRewriteFromElementsOpPass();
  });
}

//===----------------------------------------------------------------------===//
// ScalarizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerScalarizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createScalarizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerScalarizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createScalarizationPass();
  });
}

//===----------------------------------------------------------------------===//
// TileByOnePass Registration
//===----------------------------------------------------------------------===//

inline void registerTileByOnePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTileByOnePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTileByOnePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTileByOnePass();
  });
}

//===----------------------------------------------------------------------===//
// TilingSoftmaxPass Registration
//===----------------------------------------------------------------------===//

inline void registerTilingSoftmaxPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingSoftmaxPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTilingSoftmaxPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingSoftmaxPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformDotForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformDotForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformDotForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformDotForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformDotForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformElementwiseForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformElementwiseForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTransformElementwiseForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformElementwiseForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTransformElementwiseForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformMmt4DForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformMmt4DForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformMmt4DForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformMmt4DForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformMmt4DForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformPackForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformPackForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformPackForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformPackForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformPackForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformReduceForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformReduceForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTransformReduceForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformReduceForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTransformReduceForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformScatterForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformScatterForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformScatterForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformScatterForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformScatterForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// VectorizeCopyPass Registration
//===----------------------------------------------------------------------===//

inline void registerVectorizeCopyPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeCopyPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorizeCopyPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeCopyPass();
  });
}

//===----------------------------------------------------------------------===//
// VectorizeForCPUPass Registration
//===----------------------------------------------------------------------===//

inline void registerVectorizeForCPUPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeForCPUPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorizeForCPUPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeForCPUPass();
  });
}

//===----------------------------------------------------------------------===//
// GmlSt Registration
//===----------------------------------------------------------------------===//

inline void registerGmlStPasses() {
  registerAddDebugInfoPass();
  registerCollapseShapePass();
  registerCollectStatsPass();
  registerComposeExtractInsertSlicePass();
  registerFusionOutliningPass();
  registerFusionPlanningForCpuPass();
  registerInlineFusionClustersPass();
  registerLowerVectorsPass();
  registerNaiveCopyRemovalPass();
  registerOptimizeLinalgOpsPass();
  registerPackMatmulPass();
  registerRemoveLabelPass();
  registerRewriteForallOpPass();
  registerRewriteFromElementsOpPass();
  registerScalarizationPass();
  registerTileByOnePass();
  registerTilingSoftmaxPass();
  registerTransformDotForCpuPass();
  registerTransformElementwiseForCpuPass();
  registerTransformMmt4DForCpuPass();
  registerTransformPackForCpuPass();
  registerTransformReduceForCpuPass();
  registerTransformScatterForCpuPass();
  registerVectorizeCopyPass();
  registerVectorizeForCPUPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AddDebugInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugInfoPassBase;

  AddDebugInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugInfoPassBase(const AddDebugInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-info");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-info"; }

  ::llvm::StringRef getDescription() const override { return "Add debug info for the whole module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugInfoPass");
  }
  ::llvm::StringRef getName() const override { return "AddDebugInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugInfoPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CollapseShapePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CollapseShapePassBase;

  CollapseShapePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseShapePassBase(const CollapseShapePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-collapse-shape");
  }
  ::llvm::StringRef getArgument() const override { return "gml-collapse-shape"; }

  ::llvm::StringRef getDescription() const override { return "Collapse dimensions of bcasts, reductions, and cwise ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseShapePass");
  }
  ::llvm::StringRef getName() const override { return "CollapseShapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseShapePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> retainTrailingDims{*this, "retain-trailing-dims", ::llvm::cl::desc("Number of trailing dimensions that will not be collapsed."), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class CollectStatsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CollectStatsPassBase;

  CollectStatsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollectStatsPassBase(const CollectStatsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("collect-stats");
  }
  ::llvm::StringRef getArgument() const override { return "collect-stats"; }

  ::llvm::StringRef getDescription() const override { return "Print stats about tileable ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollectStatsPass");
  }
  ::llvm::StringRef getName() const override { return "CollectStatsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollectStatsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ComposeExtractInsertSlicePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ComposeExtractInsertSlicePassBase;

  ComposeExtractInsertSlicePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ComposeExtractInsertSlicePassBase(const ComposeExtractInsertSlicePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-compose-extract-insert-slice");
  }
  ::llvm::StringRef getArgument() const override { return "gml-compose-extract-insert-slice"; }

  ::llvm::StringRef getDescription() const override { return "Compose tensor.extract_slice/insert_slice ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ComposeExtractInsertSlicePass");
  }
  ::llvm::StringRef getName() const override { return "ComposeExtractInsertSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ComposeExtractInsertSlicePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FusionOutliningPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = FusionOutliningPassBase;

  FusionOutliningPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusionOutliningPassBase(const FusionOutliningPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-fusion-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "gml-fusion-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Pass to outline fusion regions into functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusionOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "FusionOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusionOutliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FusionPlanningForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusionPlanningForCpuPassBase;

  FusionPlanningForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusionPlanningForCpuPassBase(const FusionPlanningForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-fusion-planning");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-fusion-planning"; }

  ::llvm::StringRef getDescription() const override { return "Create fusion clusters."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusionPlanningForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "FusionPlanningForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::gml_st::GmlStDialect>();

  registry.insert<::mlir::linalg::LinalgDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusionPlanningForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Tile size for the innermost dimension of `linalg.map`"), ::llvm::cl::init(8)};
};

template <typename DerivedT>
class InlineFusionClustersPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = InlineFusionClustersPassBase;

  InlineFusionClustersPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InlineFusionClustersPassBase(const InlineFusionClustersPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-inline-fusion-clusters");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-inline-fusion-clusters"; }

  ::llvm::StringRef getDescription() const override { return "Replaces all gml_st.fusion op with ops from the region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InlineFusionClustersPass");
  }
  ::llvm::StringRef getName() const override { return "InlineFusionClustersPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::gml_st::GmlStDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InlineFusionClustersPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerVectorsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerVectorsPassBase;

  LowerVectorsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerVectorsPassBase(const LowerVectorsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-vectors");
  }
  ::llvm::StringRef getArgument() const override { return "lower-vectors"; }

  ::llvm::StringRef getDescription() const override { return "Pass to lower vector operations progressively."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerVectorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerVectorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::affine::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerVectorsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableAVX2{*this, "enable-avx2", ::llvm::cl::desc("Enable specialized lowerings for AVX2."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> flatten{*this, "flatten", ::llvm::cl::desc("Flatten multiple small n-D vector transfers into a large 1-D transfer."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class NaiveCopyRemovalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = NaiveCopyRemovalPassBase;

  NaiveCopyRemovalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  NaiveCopyRemovalPassBase(const NaiveCopyRemovalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("naive-copy-removal");
  }
  ::llvm::StringRef getArgument() const override { return "naive-copy-removal"; }

  ::llvm::StringRef getDescription() const override { return "Pass to remove redundant `memref.copy` ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NaiveCopyRemovalPass");
  }
  ::llvm::StringRef getName() const override { return "NaiveCopyRemovalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NaiveCopyRemovalPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OptimizeLinalgOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLinalgOpsPassBase;

  OptimizeLinalgOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLinalgOpsPassBase(const OptimizeLinalgOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-optimize-linalg-ops-pass");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-optimize-linalg-ops-pass"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalization patterns for linalg ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLinalgOpsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLinalgOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::linalg::LinalgDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLinalgOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PackMatmulPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PackMatmulPassBase;

  PackMatmulPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PackMatmulPassBase(const PackMatmulPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-pack-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-pack-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Pack linalg.matmul as linalg.mmt4d"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PackMatmulPass");
  }
  ::llvm::StringRef getName() const override { return "PackMatmulPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PackMatmulPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RemoveLabelPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveLabelPassBase;

  RemoveLabelPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveLabelPassBase(const RemoveLabelPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("remove-label");
  }
  ::llvm::StringRef getArgument() const override { return "remove-label"; }

  ::llvm::StringRef getDescription() const override { return "Remove transformed labels from tiled ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveLabelPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveLabelPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveLabelPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteForallOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteForallOpPassBase;

  RewriteForallOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteForallOpPassBase(const RewriteForallOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-rewrite-forall-ops");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-rewrite-forall-ops"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite scf.forall to scf.for."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteForallOpPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteForallOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteForallOpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteFromElementsOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteFromElementsOpPassBase;

  RewriteFromElementsOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteFromElementsOpPassBase(const RewriteFromElementsOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-rewrite-from-elements-ops");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-rewrite-from-elements-ops"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite tensor.from_elements into tensor.insert."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteFromElementsOpPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteFromElementsOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteFromElementsOpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ScalarizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ScalarizationPassBase;

  ScalarizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ScalarizationPassBase(const ScalarizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("scalarize");
  }
  ::llvm::StringRef getArgument() const override { return "scalarize"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops on tensors with 1 element to scalar ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ScalarizationPass");
  }
  ::llvm::StringRef getName() const override { return "ScalarizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithDialect>();

  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ScalarizationPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> scalarizeAllThlo{*this, "scalarize-all-thlo", ::llvm::cl::desc("Enable scalarization of thlo.concatenate/gather/scatter."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class TileByOnePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TileByOnePassBase;

  TileByOnePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TileByOnePassBase(const TileByOnePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tile-by-one");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tile-by-one"; }

  ::llvm::StringRef getDescription() const override { return "Tile all tileable ops by size 1"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TileByOnePass");
  }
  ::llvm::StringRef getName() const override { return "TileByOnePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TileByOnePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TilingSoftmaxPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingSoftmaxPassBase;

  TilingSoftmaxPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingSoftmaxPassBase(const TilingSoftmaxPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-softmax");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-softmax"; }

  ::llvm::StringRef getDescription() const override { return "Match, tile, and fuse softmax implementations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingSoftmaxPass");
  }
  ::llvm::StringRef getName() const override { return "TilingSoftmaxPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingSoftmaxPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Right-aligned tile sizes. Do not tile possible remaining dimensions"), llvm::cl::ZeroOrMore};
};

template <typename DerivedT>
class TransformDotForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformDotForCpuPassBase;

  TransformDotForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformDotForCpuPassBase(const TransformDotForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-dot");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-dot"; }

  ::llvm::StringRef getDescription() const override { return "Transform dot ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformDotForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformDotForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformDotForCpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformElementwiseForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformElementwiseForCpuPassBase;

  TransformElementwiseForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformElementwiseForCpuPassBase(const TransformElementwiseForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-elementwise");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-elementwise"; }

  ::llvm::StringRef getDescription() const override { return "Transform elementwise ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformElementwiseForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformElementwiseForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformElementwiseForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Vector size."), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<bool> fuseDegenerateReshapes{*this, "fuse-degenerate-reshapes", ::llvm::cl::desc("Fuse through degenerate tensor.expand/collapse_shape"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TransformMmt4DForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMmt4DForCpuPassBase;

  TransformMmt4DForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMmt4DForCpuPassBase(const TransformMmt4DForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-mmt4d");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-mmt4d"; }

  ::llvm::StringRef getDescription() const override { return "Transform linalg.mmt4d ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMmt4DForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMmt4DForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMmt4DForCpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformPackForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformPackForCpuPassBase;

  TransformPackForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformPackForCpuPassBase(const TransformPackForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-pack");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-pack"; }

  ::llvm::StringRef getDescription() const override { return "Transform tensor.pack/unpack ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformPackForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformPackForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformPackForCpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformReduceForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformReduceForCpuPassBase;

  TransformReduceForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformReduceForCpuPassBase(const TransformReduceForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-reduce");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-reduce"; }

  ::llvm::StringRef getDescription() const override { return "Transform reduce ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformReduceForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformReduceForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformReduceForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableHeuristic{*this, "enable_heuristic", ::llvm::cl::desc("Enable heuristic for tiling sizes. Currently only for 1D."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int64_t> tileSize1D{*this, "reduction-1d-tile-size", ::llvm::cl::desc("Tile size for a 1D reduction."), ::llvm::cl::init(32)};
  ::mlir::Pass::Option<int64_t> splitRatio1D{*this, "reduction-1d-split-ratio", ::llvm::cl::desc("Ratio used to split the reduction dimension, i.e. tiled reduce op `reduce(tensor<N>)` will be split into a composition of a  column reduction `reduce(tensor<N/splitRatio1D x splitRatio1D>)` and a row 1D reductionreduce(tensor<splitRatio1D>)`."), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<int64_t> parallelDimTileSize2D{*this, "reduction-2d-parallel-dim-tile-size", ::llvm::cl::desc("Tile size for the parallel dimension of a 2D reduction."), ::llvm::cl::init(4)};
  ::mlir::Pass::Option<int64_t> reductionDimTileSize2D{*this, "reduction-2d-reduction-dim-tile-size", ::llvm::cl::desc("Tile size for the reduction dimension of a 2D reduction."), ::llvm::cl::init(4)};
};

template <typename DerivedT>
class TransformScatterForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformScatterForCpuPassBase;

  TransformScatterForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformScatterForCpuPassBase(const TransformScatterForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-scatter");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-scatter"; }

  ::llvm::StringRef getDescription() const override { return "Transform scatter ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformScatterForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformScatterForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformScatterForCpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VectorizeCopyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeCopyPassBase;

  VectorizeCopyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeCopyPassBase(const VectorizeCopyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-copy");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-copy"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize `memref.copy`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeCopyPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeCopyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<scf::SCFDialect>();

  registry.insert<vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeCopyPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> numElementsThreshold{*this, "num-elements-threshold", ::llvm::cl::desc("Max number of elements in src and dst memref for a copy to be vectorized."), ::llvm::cl::init(8)};
};

template <typename DerivedT>
class VectorizeForCPUPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeForCPUPassBase;

  VectorizeForCPUPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeForCPUPassBase(const VectorizeForCPUPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-for-cpu");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-for-cpu"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize gml_st.for loops that are tiled perfectly."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeForCPUPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeForCPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeForCPUPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> numElementsThreshold{*this, "num-elements-threshold", ::llvm::cl::desc("Number of elements max of the tensor operands in order for the op to be vectorized."), ::llvm::cl::init(128)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
