/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Declarations                                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: VhloOps.td                                                           *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#if defined(GET_OP_CLASSES) || defined(GET_OP_FWD_DEFINES)
#undef GET_OP_FWD_DEFINES
namespace mlir {
namespace vhlo {
class AbsOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AddOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AfterAllOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllGatherOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllReduceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AllToAllOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class AndOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class Atan2OpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BatchNormGradOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BatchNormInferenceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BatchNormTrainingOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BitcastConvertOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BroadcastInDimOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class BroadcastOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CallOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CaseOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CbrtOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CeilOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CholeskyOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ClampOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ClzOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CollectivePermuteOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CompareOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ComplexOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ComputeReshapeShapeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConcatenateOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConstantOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConvertOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ConvolutionOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CosineOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CreateTokenOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CrossReplicaSumOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CstrReshapableOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class CustomCallOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DivOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DotGeneralOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DotOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicBroadcastInDimOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicConvOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicGatherOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicIotaOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicPadOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicReshapeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicSliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class DynamicUpdateSliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class EinsumOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ExpOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class Expm1OpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class FftOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class FloorOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class FuncOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class GatherOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class GetDimensionSizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class GetTupleElementOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class IfOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ImagOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class InfeedOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class IotaOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class IsFiniteOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class Log1pOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class LogOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class LogisticOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MapOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MaxOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MinOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class MulOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class NegOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class NotOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class OptimizationBarrierOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class OrOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class OutfeedOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PadOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PartitionIdOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PopulationCountOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class PowOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RealDynamicSliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RealOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RecvOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReduceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReducePrecisionOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReduceScatterOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReduceWindowOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RemOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReplicaIdOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReshapeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReturnOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ReverseOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RngBitGeneratorOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RngOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RoundNearestEvenOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RoundOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class RsqrtOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ScatterOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SelectAndScatterOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SelectOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SendOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SetDimensionSizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ShiftLeftOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ShiftRightArithmeticOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class ShiftRightLogicalOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SignOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SineOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SliceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SortOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SqrtOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class SubtractOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TanhOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TorchIndexSelectOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TraceOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TransposeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TriangularSolveOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class TupleOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class UnaryEinsumOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class UniformDequantizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class UniformQuantizeOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class WhileOpV1;
} // namespace vhlo
} // namespace mlir
namespace mlir {
namespace vhlo {
class XorOpV1;
} // namespace vhlo
} // namespace mlir
#endif

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AbsOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AbsOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AbsOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AbsOpV1GenericAdaptorBase(AbsOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class AbsOpV1GenericAdaptor : public detail::AbsOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AbsOpV1GenericAdaptorBase;
public:
  AbsOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AbsOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AbsOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AbsOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AbsOpV1>>>
  AbsOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AbsOpV1Adaptor : public AbsOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AbsOpV1GenericAdaptor::AbsOpV1GenericAdaptor;
  AbsOpV1Adaptor(AbsOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AbsOpV1 : public ::mlir::Op<AbsOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AbsOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AbsOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.abs_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AbsOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AddOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AddOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AddOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AddOpV1GenericAdaptorBase(AddOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class AddOpV1GenericAdaptor : public detail::AddOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AddOpV1GenericAdaptorBase;
public:
  AddOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AddOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AddOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AddOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AddOpV1>>>
  AddOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AddOpV1Adaptor : public AddOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AddOpV1GenericAdaptor::AddOpV1GenericAdaptor;
  AddOpV1Adaptor(AddOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AddOpV1 : public ::mlir::Op<AddOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AddOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AddOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.add_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AddOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AfterAllOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AfterAllOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AfterAllOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AfterAllOpV1GenericAdaptorBase(AfterAllOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class AfterAllOpV1GenericAdaptor : public detail::AfterAllOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AfterAllOpV1GenericAdaptorBase;
public:
  AfterAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AfterAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AfterAllOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AfterAllOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AfterAllOpV1>>>
  AfterAllOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AfterAllOpV1Adaptor : public AfterAllOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AfterAllOpV1GenericAdaptor::AfterAllOpV1GenericAdaptor;
  AfterAllOpV1Adaptor(AfterAllOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AfterAllOpV1 : public ::mlir::Op<AfterAllOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AfterAllOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AfterAllOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.after_all_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AfterAllOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllGatherOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllGatherOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AllGatherOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AllGatherOpV1GenericAdaptorBase(AllGatherOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getAllGatherDimAttr();
  ::mlir::Attribute getAllGatherDim();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr();
  ::mlir::Attribute getUseGlobalDeviceIds();
};
} // namespace detail
template <typename RangeT>
class AllGatherOpV1GenericAdaptor : public detail::AllGatherOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllGatherOpV1GenericAdaptorBase;
public:
  AllGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllGatherOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AllGatherOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AllGatherOpV1>>>
  AllGatherOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllGatherOpV1Adaptor : public AllGatherOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AllGatherOpV1GenericAdaptor::AllGatherOpV1GenericAdaptor;
  AllGatherOpV1Adaptor(AllGatherOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AllGatherOpV1 : public ::mlir::Op<AllGatherOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllGatherOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllGatherOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("all_gather_dim"), ::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getAllGatherDimAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getAllGatherDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_gather_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getAllGatherDimAttr();
  ::mlir::Attribute getAllGatherDim();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr();
  ::mlir::Attribute getUseGlobalDeviceIds();
  void setAllGatherDimAttr(::mlir::Attribute attr);
  void setReplicaGroupsAttr(::mlir::Attribute attr);
  void setChannelIdAttr(::mlir::Attribute attr);
  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute all_gather_dim, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllGatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllReduceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllReduceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AllReduceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AllReduceOpV1GenericAdaptorBase(AllReduceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr();
  ::mlir::Attribute getUseGlobalDeviceIds();
  ::mlir::Region &getComputation();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class AllReduceOpV1GenericAdaptor : public detail::AllReduceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllReduceOpV1GenericAdaptorBase;
public:
  AllReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllReduceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AllReduceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AllReduceOpV1>>>
  AllReduceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllReduceOpV1Adaptor : public AllReduceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AllReduceOpV1GenericAdaptor::AllReduceOpV1GenericAdaptor;
  AllReduceOpV1Adaptor(AllReduceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AllReduceOpV1 : public ::mlir::Op<AllReduceOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllReduceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllReduceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_reduce_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Region &getComputation();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr();
  ::mlir::Attribute getUseGlobalDeviceIds();
  void setReplicaGroupsAttr(::mlir::Attribute attr);
  void setChannelIdAttr(::mlir::Attribute attr);
  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllReduceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AllToAllOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllToAllOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AllToAllOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AllToAllOpV1GenericAdaptorBase(AllToAllOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getSplitDimensionAttr();
  ::mlir::Attribute getSplitDimension();
  ::mlir::Attribute getConcatDimensionAttr();
  ::mlir::Attribute getConcatDimension();
  ::mlir::Attribute getSplitCountAttr();
  ::mlir::Attribute getSplitCount();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
};
} // namespace detail
template <typename RangeT>
class AllToAllOpV1GenericAdaptor : public detail::AllToAllOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllToAllOpV1GenericAdaptorBase;
public:
  AllToAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllToAllOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllToAllOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AllToAllOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AllToAllOpV1>>>
  AllToAllOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllToAllOpV1Adaptor : public AllToAllOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AllToAllOpV1GenericAdaptor::AllToAllOpV1GenericAdaptor;
  AllToAllOpV1Adaptor(AllToAllOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AllToAllOpV1 : public ::mlir::Op<AllToAllOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllToAllOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AllToAllOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("concat_dimension"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("split_count"), ::llvm::StringRef("split_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getConcatDimensionAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getConcatDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getSplitCountAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getSplitCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSplitDimensionAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSplitDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.all_to_all_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getSplitDimensionAttr();
  ::mlir::Attribute getSplitDimension();
  ::mlir::Attribute getConcatDimensionAttr();
  ::mlir::Attribute getConcatDimension();
  ::mlir::Attribute getSplitCountAttr();
  ::mlir::Attribute getSplitCount();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  void setSplitDimensionAttr(::mlir::Attribute attr);
  void setConcatDimensionAttr(::mlir::Attribute attr);
  void setSplitCountAttr(::mlir::Attribute attr);
  void setReplicaGroupsAttr(::mlir::Attribute attr);
  void setChannelIdAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute split_dimension, ::mlir::Attribute concat_dimension, ::mlir::Attribute split_count, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AllToAllOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::AndOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AndOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AndOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AndOpV1GenericAdaptorBase(AndOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class AndOpV1GenericAdaptor : public detail::AndOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AndOpV1GenericAdaptorBase;
public:
  AndOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AndOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AndOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AndOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, AndOpV1>>>
  AndOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AndOpV1Adaptor : public AndOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using AndOpV1GenericAdaptor::AndOpV1GenericAdaptor;
  AndOpV1Adaptor(AndOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AndOpV1 : public ::mlir::Op<AndOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AndOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = AndOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.and_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::AndOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Atan2OpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class Atan2OpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  Atan2OpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  Atan2OpV1GenericAdaptorBase(Atan2OpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class Atan2OpV1GenericAdaptor : public detail::Atan2OpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::Atan2OpV1GenericAdaptorBase;
public:
  Atan2OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  Atan2OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : Atan2OpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = Atan2OpV1, typename = std::enable_if_t<std::is_same_v<LateInst, Atan2OpV1>>>
  Atan2OpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class Atan2OpV1Adaptor : public Atan2OpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using Atan2OpV1GenericAdaptor::Atan2OpV1GenericAdaptor;
  Atan2OpV1Adaptor(Atan2OpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class Atan2OpV1 : public ::mlir::Op<Atan2OpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Atan2OpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = Atan2OpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.atan2_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::Atan2OpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormGradOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BatchNormGradOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BatchNormGradOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  BatchNormGradOpV1GenericAdaptorBase(BatchNormGradOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getEpsilonAttr();
  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr();
  ::mlir::Attribute getFeatureIndex();
};
} // namespace detail
template <typename RangeT>
class BatchNormGradOpV1GenericAdaptor : public detail::BatchNormGradOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BatchNormGradOpV1GenericAdaptorBase;
public:
  BatchNormGradOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BatchNormGradOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BatchNormGradOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BatchNormGradOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BatchNormGradOpV1>>>
  BatchNormGradOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getScale() {
    return (*getODSOperands(1).begin());
  }

  ValueT getMean() {
    return (*getODSOperands(2).begin());
  }

  ValueT getVariance() {
    return (*getODSOperands(3).begin());
  }

  ValueT getGradOutput() {
    return (*getODSOperands(4).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BatchNormGradOpV1Adaptor : public BatchNormGradOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BatchNormGradOpV1GenericAdaptor::BatchNormGradOpV1GenericAdaptor;
  BatchNormGradOpV1Adaptor(BatchNormGradOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class BatchNormGradOpV1 : public ::mlir::Op<BatchNormGradOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BatchNormGradOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BatchNormGradOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("epsilon"), ::llvm::StringRef("feature_index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEpsilonAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEpsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureIndexAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.batch_norm_grad_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getScale();
  ::mlir::Value getMean();
  ::mlir::Value getVariance();
  ::mlir::Value getGradOutput();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getScaleMutable();
  ::mlir::OpOperand &getMeanMutable();
  ::mlir::OpOperand &getVarianceMutable();
  ::mlir::OpOperand &getGradOutputMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getGradOperand();
  ::mlir::Value getGradScale();
  ::mlir::Value getGradOffset();
  ::mlir::Attribute getEpsilonAttr();
  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr();
  ::mlir::Attribute getFeatureIndex();
  void setEpsilonAttr(::mlir::Attribute attr);
  void setFeatureIndexAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type grad_operand, ::mlir::Type grad_scale, ::mlir::Type grad_offset, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Value grad_output, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Value grad_output, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormGradOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormInferenceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BatchNormInferenceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BatchNormInferenceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  BatchNormInferenceOpV1GenericAdaptorBase(BatchNormInferenceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getEpsilonAttr();
  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr();
  ::mlir::Attribute getFeatureIndex();
};
} // namespace detail
template <typename RangeT>
class BatchNormInferenceOpV1GenericAdaptor : public detail::BatchNormInferenceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BatchNormInferenceOpV1GenericAdaptorBase;
public:
  BatchNormInferenceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BatchNormInferenceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BatchNormInferenceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BatchNormInferenceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BatchNormInferenceOpV1>>>
  BatchNormInferenceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getScale() {
    return (*getODSOperands(1).begin());
  }

  ValueT getOffset() {
    return (*getODSOperands(2).begin());
  }

  ValueT getMean() {
    return (*getODSOperands(3).begin());
  }

  ValueT getVariance() {
    return (*getODSOperands(4).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BatchNormInferenceOpV1Adaptor : public BatchNormInferenceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BatchNormInferenceOpV1GenericAdaptor::BatchNormInferenceOpV1GenericAdaptor;
  BatchNormInferenceOpV1Adaptor(BatchNormInferenceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class BatchNormInferenceOpV1 : public ::mlir::Op<BatchNormInferenceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BatchNormInferenceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BatchNormInferenceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("epsilon"), ::llvm::StringRef("feature_index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEpsilonAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEpsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureIndexAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.batch_norm_inference_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getScale();
  ::mlir::Value getOffset();
  ::mlir::Value getMean();
  ::mlir::Value getVariance();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getScaleMutable();
  ::mlir::OpOperand &getOffsetMutable();
  ::mlir::OpOperand &getMeanMutable();
  ::mlir::OpOperand &getVarianceMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getEpsilonAttr();
  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr();
  ::mlir::Attribute getFeatureIndex();
  void setEpsilonAttr(::mlir::Attribute attr);
  void setFeatureIndexAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Value mean, ::mlir::Value variance, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormInferenceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BatchNormTrainingOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BatchNormTrainingOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BatchNormTrainingOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  BatchNormTrainingOpV1GenericAdaptorBase(BatchNormTrainingOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getEpsilonAttr();
  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr();
  ::mlir::Attribute getFeatureIndex();
};
} // namespace detail
template <typename RangeT>
class BatchNormTrainingOpV1GenericAdaptor : public detail::BatchNormTrainingOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BatchNormTrainingOpV1GenericAdaptorBase;
public:
  BatchNormTrainingOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BatchNormTrainingOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BatchNormTrainingOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BatchNormTrainingOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BatchNormTrainingOpV1>>>
  BatchNormTrainingOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getScale() {
    return (*getODSOperands(1).begin());
  }

  ValueT getOffset() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BatchNormTrainingOpV1Adaptor : public BatchNormTrainingOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BatchNormTrainingOpV1GenericAdaptor::BatchNormTrainingOpV1GenericAdaptor;
  BatchNormTrainingOpV1Adaptor(BatchNormTrainingOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class BatchNormTrainingOpV1 : public ::mlir::Op<BatchNormTrainingOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::NResults<3>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BatchNormTrainingOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BatchNormTrainingOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("epsilon"), ::llvm::StringRef("feature_index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEpsilonAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEpsilonAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureIndexAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.batch_norm_training_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getScale();
  ::mlir::Value getOffset();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getScaleMutable();
  ::mlir::OpOperand &getOffsetMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getOutput();
  ::mlir::Value getBatchMean();
  ::mlir::Value getBatchVar();
  ::mlir::Attribute getEpsilonAttr();
  ::mlir::Attribute getEpsilon();
  ::mlir::Attribute getFeatureIndexAttr();
  ::mlir::Attribute getFeatureIndex();
  void setEpsilonAttr(::mlir::Attribute attr);
  void setFeatureIndexAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Type batch_mean, ::mlir::Type batch_var, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value scale, ::mlir::Value offset, ::mlir::Attribute epsilon, ::mlir::Attribute feature_index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BatchNormTrainingOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BitcastConvertOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BitcastConvertOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BitcastConvertOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  BitcastConvertOpV1GenericAdaptorBase(BitcastConvertOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class BitcastConvertOpV1GenericAdaptor : public detail::BitcastConvertOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BitcastConvertOpV1GenericAdaptorBase;
public:
  BitcastConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BitcastConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BitcastConvertOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BitcastConvertOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BitcastConvertOpV1>>>
  BitcastConvertOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BitcastConvertOpV1Adaptor : public BitcastConvertOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BitcastConvertOpV1GenericAdaptor::BitcastConvertOpV1GenericAdaptor;
  BitcastConvertOpV1Adaptor(BitcastConvertOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class BitcastConvertOpV1 : public ::mlir::Op<BitcastConvertOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BitcastConvertOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BitcastConvertOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.bitcast_convert_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BitcastConvertOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BroadcastInDimOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BroadcastInDimOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BroadcastInDimOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  BroadcastInDimOpV1GenericAdaptorBase(BroadcastInDimOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getBroadcastDimensionsAttr();
  ::mlir::Attribute getBroadcastDimensions();
};
} // namespace detail
template <typename RangeT>
class BroadcastInDimOpV1GenericAdaptor : public detail::BroadcastInDimOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BroadcastInDimOpV1GenericAdaptorBase;
public:
  BroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BroadcastInDimOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BroadcastInDimOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BroadcastInDimOpV1>>>
  BroadcastInDimOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BroadcastInDimOpV1Adaptor : public BroadcastInDimOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BroadcastInDimOpV1GenericAdaptor::BroadcastInDimOpV1GenericAdaptor;
  BroadcastInDimOpV1Adaptor(BroadcastInDimOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class BroadcastInDimOpV1 : public ::mlir::Op<BroadcastInDimOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BroadcastInDimOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BroadcastInDimOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("broadcast_dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBroadcastDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBroadcastDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.broadcast_in_dim_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getBroadcastDimensionsAttr();
  ::mlir::Attribute getBroadcastDimensions();
  void setBroadcastDimensionsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute broadcast_dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute broadcast_dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BroadcastInDimOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::BroadcastOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class BroadcastOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  BroadcastOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  BroadcastOpV1GenericAdaptorBase(BroadcastOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getBroadcastSizesAttr();
  ::mlir::Attribute getBroadcastSizes();
};
} // namespace detail
template <typename RangeT>
class BroadcastOpV1GenericAdaptor : public detail::BroadcastOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::BroadcastOpV1GenericAdaptorBase;
public:
  BroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  BroadcastOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : BroadcastOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = BroadcastOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, BroadcastOpV1>>>
  BroadcastOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class BroadcastOpV1Adaptor : public BroadcastOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using BroadcastOpV1GenericAdaptor::BroadcastOpV1GenericAdaptor;
  BroadcastOpV1Adaptor(BroadcastOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class BroadcastOpV1 : public ::mlir::Op<BroadcastOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = BroadcastOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = BroadcastOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("broadcast_sizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBroadcastSizesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBroadcastSizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.broadcast_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getBroadcastSizesAttr();
  ::mlir::Attribute getBroadcastSizes();
  void setBroadcastSizesAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute broadcast_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute broadcast_sizes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::BroadcastOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CallOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CallOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CallOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CallOpV1GenericAdaptorBase(CallOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getCalleeAttr();
  ::mlir::Attribute getCallee();
};
} // namespace detail
template <typename RangeT>
class CallOpV1GenericAdaptor : public detail::CallOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CallOpV1GenericAdaptorBase;
public:
  CallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CallOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CallOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CallOpV1>>>
  CallOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return getODSOperands(0);
  }

private:
  RangeT odsOperands;
};
class CallOpV1Adaptor : public CallOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CallOpV1GenericAdaptor::CallOpV1GenericAdaptor;
  CallOpV1Adaptor(CallOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CallOpV1 : public ::mlir::Op<CallOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CallOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CallOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("callee")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCalleeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCalleeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.call_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getOperands();
  ::mlir::MutableOperandRange getOperandsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Attribute getCalleeAttr();
  ::mlir::Attribute getCallee();
  void setCalleeAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Attribute callee, ::mlir::ValueRange operands);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CallOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CaseOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CaseOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CaseOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CaseOpV1GenericAdaptorBase(CaseOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::RegionRange getBranches();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class CaseOpV1GenericAdaptor : public detail::CaseOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CaseOpV1GenericAdaptorBase;
public:
  CaseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CaseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CaseOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CaseOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CaseOpV1>>>
  CaseOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getIndex() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CaseOpV1Adaptor : public CaseOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CaseOpV1GenericAdaptor::CaseOpV1GenericAdaptor;
  CaseOpV1Adaptor(CaseOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CaseOpV1 : public ::mlir::Op<CaseOpV1, ::mlir::OpTrait::VariadicRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CaseOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CaseOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.case_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getIndex();
  ::mlir::OpOperand &getIndexMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::MutableArrayRef<::mlir::Region> getBranches();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value index, unsigned branchesCount);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes, unsigned numRegions);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CaseOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CbrtOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CbrtOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CbrtOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CbrtOpV1GenericAdaptorBase(CbrtOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class CbrtOpV1GenericAdaptor : public detail::CbrtOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CbrtOpV1GenericAdaptorBase;
public:
  CbrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CbrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CbrtOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CbrtOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CbrtOpV1>>>
  CbrtOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CbrtOpV1Adaptor : public CbrtOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CbrtOpV1GenericAdaptor::CbrtOpV1GenericAdaptor;
  CbrtOpV1Adaptor(CbrtOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CbrtOpV1 : public ::mlir::Op<CbrtOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CbrtOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CbrtOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cbrt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CbrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CeilOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CeilOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CeilOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CeilOpV1GenericAdaptorBase(CeilOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class CeilOpV1GenericAdaptor : public detail::CeilOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CeilOpV1GenericAdaptorBase;
public:
  CeilOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CeilOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CeilOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CeilOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CeilOpV1>>>
  CeilOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CeilOpV1Adaptor : public CeilOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CeilOpV1GenericAdaptor::CeilOpV1GenericAdaptor;
  CeilOpV1Adaptor(CeilOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CeilOpV1 : public ::mlir::Op<CeilOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CeilOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CeilOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.ceil_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CeilOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CholeskyOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CholeskyOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CholeskyOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CholeskyOpV1GenericAdaptorBase(CholeskyOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getLowerAttr();
  ::mlir::Attribute getLower();
};
} // namespace detail
template <typename RangeT>
class CholeskyOpV1GenericAdaptor : public detail::CholeskyOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CholeskyOpV1GenericAdaptorBase;
public:
  CholeskyOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CholeskyOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CholeskyOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CholeskyOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CholeskyOpV1>>>
  CholeskyOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getA() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CholeskyOpV1Adaptor : public CholeskyOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CholeskyOpV1GenericAdaptor::CholeskyOpV1GenericAdaptor;
  CholeskyOpV1Adaptor(CholeskyOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CholeskyOpV1 : public ::mlir::Op<CholeskyOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CholeskyOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CholeskyOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("lower")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLowerAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLowerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cholesky_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getA();
  ::mlir::OpOperand &getAMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getLowerAttr();
  ::mlir::Attribute getLower();
  void setLowerAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Attribute lower);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Attribute lower);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CholeskyOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ClampOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ClampOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ClampOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ClampOpV1GenericAdaptorBase(ClampOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ClampOpV1GenericAdaptor : public detail::ClampOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ClampOpV1GenericAdaptorBase;
public:
  ClampOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ClampOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ClampOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ClampOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ClampOpV1>>>
  ClampOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getMin() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOperand() {
    return (*getODSOperands(1).begin());
  }

  ValueT getMax() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ClampOpV1Adaptor : public ClampOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ClampOpV1GenericAdaptor::ClampOpV1GenericAdaptor;
  ClampOpV1Adaptor(ClampOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ClampOpV1 : public ::mlir::Op<ClampOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ClampOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ClampOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.clamp_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getMin();
  ::mlir::Value getOperand();
  ::mlir::Value getMax();
  ::mlir::OpOperand &getMinMutable();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getMaxMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value min, ::mlir::Value operand, ::mlir::Value max);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value min, ::mlir::Value operand, ::mlir::Value max);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ClampOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ClzOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ClzOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ClzOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ClzOpV1GenericAdaptorBase(ClzOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ClzOpV1GenericAdaptor : public detail::ClzOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ClzOpV1GenericAdaptorBase;
public:
  ClzOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ClzOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ClzOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ClzOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ClzOpV1>>>
  ClzOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ClzOpV1Adaptor : public ClzOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ClzOpV1GenericAdaptor::ClzOpV1GenericAdaptor;
  ClzOpV1Adaptor(ClzOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ClzOpV1 : public ::mlir::Op<ClzOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ClzOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ClzOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.count_leading_zeros_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ClzOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CollectivePermuteOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CollectivePermuteOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CollectivePermuteOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CollectivePermuteOpV1GenericAdaptorBase(CollectivePermuteOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getSourceTargetPairsAttr();
  ::mlir::Attribute getSourceTargetPairs();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
};
} // namespace detail
template <typename RangeT>
class CollectivePermuteOpV1GenericAdaptor : public detail::CollectivePermuteOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CollectivePermuteOpV1GenericAdaptorBase;
public:
  CollectivePermuteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CollectivePermuteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CollectivePermuteOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CollectivePermuteOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CollectivePermuteOpV1>>>
  CollectivePermuteOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CollectivePermuteOpV1Adaptor : public CollectivePermuteOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CollectivePermuteOpV1GenericAdaptor::CollectivePermuteOpV1GenericAdaptor;
  CollectivePermuteOpV1Adaptor(CollectivePermuteOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CollectivePermuteOpV1 : public ::mlir::Op<CollectivePermuteOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CollectivePermuteOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CollectivePermuteOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("source_target_pairs")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getSourceTargetPairsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getSourceTargetPairsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.collective_permute_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getSourceTargetPairsAttr();
  ::mlir::Attribute getSourceTargetPairs();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  void setSourceTargetPairsAttr(::mlir::Attribute attr);
  void setChannelIdAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute source_target_pairs, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute source_target_pairs, ::mlir::Attribute channel_id);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CollectivePermuteOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CompareOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CompareOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CompareOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CompareOpV1GenericAdaptorBase(CompareOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getComparisonDirectionAttr();
  ::mlir::Attribute getComparisonDirection();
  ::mlir::Attribute getCompareTypeAttr();
  ::mlir::Attribute getCompareType();
};
} // namespace detail
template <typename RangeT>
class CompareOpV1GenericAdaptor : public detail::CompareOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CompareOpV1GenericAdaptorBase;
public:
  CompareOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CompareOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CompareOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CompareOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CompareOpV1>>>
  CompareOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CompareOpV1Adaptor : public CompareOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CompareOpV1GenericAdaptor::CompareOpV1GenericAdaptor;
  CompareOpV1Adaptor(CompareOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CompareOpV1 : public ::mlir::Op<CompareOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CompareOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CompareOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("compare_type"), ::llvm::StringRef("comparison_direction")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCompareTypeAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCompareTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getComparisonDirectionAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getComparisonDirectionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.compare_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getComparisonDirectionAttr();
  ::mlir::Attribute getComparisonDirection();
  ::mlir::Attribute getCompareTypeAttr();
  ::mlir::Attribute getCompareType();
  void setComparisonDirectionAttr(::mlir::Attribute attr);
  void setCompareTypeAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute comparison_direction, ::mlir::Attribute compare_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute comparison_direction, ::mlir::Attribute compare_type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CompareOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ComplexOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ComplexOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ComplexOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ComplexOpV1GenericAdaptorBase(ComplexOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ComplexOpV1GenericAdaptor : public detail::ComplexOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ComplexOpV1GenericAdaptorBase;
public:
  ComplexOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ComplexOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ComplexOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ComplexOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ComplexOpV1>>>
  ComplexOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ComplexOpV1Adaptor : public ComplexOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ComplexOpV1GenericAdaptor::ComplexOpV1GenericAdaptor;
  ComplexOpV1Adaptor(ComplexOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ComplexOpV1 : public ::mlir::Op<ComplexOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ComplexOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ComplexOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.complex_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ComplexOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ComputeReshapeShapeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ComputeReshapeShapeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ComputeReshapeShapeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ComputeReshapeShapeOpV1GenericAdaptorBase(ComputeReshapeShapeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ComputeReshapeShapeOpV1GenericAdaptor : public detail::ComputeReshapeShapeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ComputeReshapeShapeOpV1GenericAdaptorBase;
public:
  ComputeReshapeShapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ComputeReshapeShapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ComputeReshapeShapeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ComputeReshapeShapeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ComputeReshapeShapeOpV1>>>
  ComputeReshapeShapeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getNumElements() {
    return (*getODSOperands(0).begin());
  }

  ValueT getDynamicShape() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ComputeReshapeShapeOpV1Adaptor : public ComputeReshapeShapeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ComputeReshapeShapeOpV1GenericAdaptor::ComputeReshapeShapeOpV1GenericAdaptor;
  ComputeReshapeShapeOpV1Adaptor(ComputeReshapeShapeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ComputeReshapeShapeOpV1 : public ::mlir::Op<ComputeReshapeShapeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ComputeReshapeShapeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ComputeReshapeShapeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.compute_reshape_shape_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getNumElements();
  ::mlir::Value getDynamicShape();
  ::mlir::OpOperand &getNumElementsMutable();
  ::mlir::OpOperand &getDynamicShapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value num_elements, ::mlir::Value dynamic_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value num_elements, ::mlir::Value dynamic_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ComputeReshapeShapeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConcatenateOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConcatenateOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ConcatenateOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ConcatenateOpV1GenericAdaptorBase(ConcatenateOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
};
} // namespace detail
template <typename RangeT>
class ConcatenateOpV1GenericAdaptor : public detail::ConcatenateOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConcatenateOpV1GenericAdaptorBase;
public:
  ConcatenateOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConcatenateOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConcatenateOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ConcatenateOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConcatenateOpV1>>>
  ConcatenateOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConcatenateOpV1Adaptor : public ConcatenateOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConcatenateOpV1GenericAdaptor::ConcatenateOpV1GenericAdaptor;
  ConcatenateOpV1Adaptor(ConcatenateOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ConcatenateOpV1 : public ::mlir::Op<ConcatenateOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConcatenateOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConcatenateOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.concatenate_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
  void setDimensionAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConcatenateOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConstantOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConstantOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ConstantOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ConstantOpV1GenericAdaptorBase(ConstantOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getValueAttr();
  ::mlir::Attribute getValue();
};
} // namespace detail
template <typename RangeT>
class ConstantOpV1GenericAdaptor : public detail::ConstantOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConstantOpV1GenericAdaptorBase;
public:
  ConstantOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConstantOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConstantOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ConstantOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConstantOpV1>>>
  ConstantOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConstantOpV1Adaptor : public ConstantOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConstantOpV1GenericAdaptor::ConstantOpV1GenericAdaptor;
  ConstantOpV1Adaptor(ConstantOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ConstantOpV1 : public ::mlir::Op<ConstantOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConstantOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConstantOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("value")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getValueAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getValueAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.constant_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getOutput();
  ::mlir::Attribute getValueAttr();
  ::mlir::Attribute getValue();
  void setValueAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Attribute value);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute value);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConstantOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConvertOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConvertOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ConvertOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ConvertOpV1GenericAdaptorBase(ConvertOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ConvertOpV1GenericAdaptor : public detail::ConvertOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConvertOpV1GenericAdaptorBase;
public:
  ConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConvertOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConvertOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ConvertOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConvertOpV1>>>
  ConvertOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConvertOpV1Adaptor : public ConvertOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConvertOpV1GenericAdaptor::ConvertOpV1GenericAdaptor;
  ConvertOpV1Adaptor(ConvertOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ConvertOpV1 : public ::mlir::Op<ConvertOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConvertOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConvertOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.convert_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConvertOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ConvolutionOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConvolutionOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ConvolutionOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ConvolutionOpV1GenericAdaptorBase(ConvolutionOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr();
  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr();
  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr();
  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr();
  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr();
  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr();
  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr();
  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr();
  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr();
  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr();
  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr();
  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr();
  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr();
  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr();
  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class ConvolutionOpV1GenericAdaptor : public detail::ConvolutionOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConvolutionOpV1GenericAdaptorBase;
public:
  ConvolutionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConvolutionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConvolutionOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ConvolutionOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ConvolutionOpV1>>>
  ConvolutionOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConvolutionOpV1Adaptor : public ConvolutionOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ConvolutionOpV1GenericAdaptor::ConvolutionOpV1GenericAdaptor;
  ConvolutionOpV1Adaptor(ConvolutionOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ConvolutionOpV1 : public ::mlir::Op<ConvolutionOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConvolutionOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ConvolutionOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_group_count"), ::llvm::StringRef("feature_group_count"), ::llvm::StringRef("input_batch_dimension"), ::llvm::StringRef("input_feature_dimension"), ::llvm::StringRef("input_spatial_dimensions"), ::llvm::StringRef("kernel_input_feature_dimension"), ::llvm::StringRef("kernel_output_feature_dimension"), ::llvm::StringRef("kernel_spatial_dimensions"), ::llvm::StringRef("lhs_dilation"), ::llvm::StringRef("output_batch_dimension"), ::llvm::StringRef("output_feature_dimension"), ::llvm::StringRef("output_spatial_dimensions"), ::llvm::StringRef("padding"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_dilation"), ::llvm::StringRef("window_reversal"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchGroupCountAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureGroupCountAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInputBatchDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getInputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getInputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getKernelInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getKernelInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getKernelSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getKernelSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getLhsDilationAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getLhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getOutputBatchDimensionAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getOutputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getOutputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getOutputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getRhsDilationAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getRhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getWindowReversalAttrName() {
    return getAttributeNameForIndex(15);
  }

  static ::mlir::StringAttr getWindowReversalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 15);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(16);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 16);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.convolution_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr();
  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr();
  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr();
  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr();
  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr();
  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr();
  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr();
  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr();
  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr();
  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr();
  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr();
  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr();
  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr();
  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr();
  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
  void setWindowStridesAttr(::mlir::Attribute attr);
  void setPaddingAttr(::mlir::Attribute attr);
  void setLhsDilationAttr(::mlir::Attribute attr);
  void setRhsDilationAttr(::mlir::Attribute attr);
  void setWindowReversalAttr(::mlir::Attribute attr);
  void setInputBatchDimensionAttr(::mlir::Attribute attr);
  void setInputFeatureDimensionAttr(::mlir::Attribute attr);
  void setInputSpatialDimensionsAttr(::mlir::Attribute attr);
  void setKernelInputFeatureDimensionAttr(::mlir::Attribute attr);
  void setKernelOutputFeatureDimensionAttr(::mlir::Attribute attr);
  void setKernelSpatialDimensionsAttr(::mlir::Attribute attr);
  void setOutputBatchDimensionAttr(::mlir::Attribute attr);
  void setOutputFeatureDimensionAttr(::mlir::Attribute attr);
  void setOutputSpatialDimensionsAttr(::mlir::Attribute attr);
  void setFeatureGroupCountAttr(::mlir::Attribute attr);
  void setBatchGroupCountAttr(::mlir::Attribute attr);
  void setPrecisionConfigAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 17 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ConvolutionOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CosineOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CosineOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CosineOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CosineOpV1GenericAdaptorBase(CosineOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class CosineOpV1GenericAdaptor : public detail::CosineOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CosineOpV1GenericAdaptorBase;
public:
  CosineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CosineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CosineOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CosineOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CosineOpV1>>>
  CosineOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CosineOpV1Adaptor : public CosineOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CosineOpV1GenericAdaptor::CosineOpV1GenericAdaptor;
  CosineOpV1Adaptor(CosineOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CosineOpV1 : public ::mlir::Op<CosineOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CosineOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CosineOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cosine_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CosineOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CreateTokenOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CreateTokenOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CreateTokenOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CreateTokenOpV1GenericAdaptorBase(CreateTokenOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class CreateTokenOpV1GenericAdaptor : public detail::CreateTokenOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CreateTokenOpV1GenericAdaptorBase;
public:
  CreateTokenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CreateTokenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CreateTokenOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CreateTokenOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CreateTokenOpV1>>>
  CreateTokenOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CreateTokenOpV1Adaptor : public CreateTokenOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CreateTokenOpV1GenericAdaptor::CreateTokenOpV1GenericAdaptor;
  CreateTokenOpV1Adaptor(CreateTokenOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CreateTokenOpV1 : public ::mlir::Op<CreateTokenOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CreateTokenOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CreateTokenOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.create_token_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getOutput();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CreateTokenOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CrossReplicaSumOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CrossReplicaSumOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CrossReplicaSumOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CrossReplicaSumOpV1GenericAdaptorBase(CrossReplicaSumOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
};
} // namespace detail
template <typename RangeT>
class CrossReplicaSumOpV1GenericAdaptor : public detail::CrossReplicaSumOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CrossReplicaSumOpV1GenericAdaptorBase;
public:
  CrossReplicaSumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CrossReplicaSumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CrossReplicaSumOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CrossReplicaSumOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CrossReplicaSumOpV1>>>
  CrossReplicaSumOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CrossReplicaSumOpV1Adaptor : public CrossReplicaSumOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CrossReplicaSumOpV1GenericAdaptor::CrossReplicaSumOpV1GenericAdaptor;
  CrossReplicaSumOpV1Adaptor(CrossReplicaSumOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CrossReplicaSumOpV1 : public ::mlir::Op<CrossReplicaSumOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CrossReplicaSumOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CrossReplicaSumOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("replica_groups")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cross-replica-sum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  void setReplicaGroupsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute replica_groups);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute replica_groups);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CrossReplicaSumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CstrReshapableOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CstrReshapableOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CstrReshapableOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CstrReshapableOpV1GenericAdaptorBase(CstrReshapableOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class CstrReshapableOpV1GenericAdaptor : public detail::CstrReshapableOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CstrReshapableOpV1GenericAdaptorBase;
public:
  CstrReshapableOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CstrReshapableOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CstrReshapableOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CstrReshapableOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CstrReshapableOpV1>>>
  CstrReshapableOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getNumElements() {
    return (*getODSOperands(0).begin());
  }

  ValueT getDynamicShape() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CstrReshapableOpV1Adaptor : public CstrReshapableOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CstrReshapableOpV1GenericAdaptor::CstrReshapableOpV1GenericAdaptor;
  CstrReshapableOpV1Adaptor(CstrReshapableOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CstrReshapableOpV1 : public ::mlir::Op<CstrReshapableOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CstrReshapableOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CstrReshapableOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.cstr_reshapable_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getNumElements();
  ::mlir::Value getDynamicShape();
  ::mlir::OpOperand &getNumElementsMutable();
  ::mlir::OpOperand &getDynamicShapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value num_elements, ::mlir::Value dynamic_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value num_elements, ::mlir::Value dynamic_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CstrReshapableOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::CustomCallOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CustomCallOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  CustomCallOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  CustomCallOpV1GenericAdaptorBase(CustomCallOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getCallTargetNameAttr();
  ::mlir::Attribute getCallTargetName();
  ::mlir::Attribute getHasSideEffectAttr();
  ::mlir::Attribute getHasSideEffect();
  ::mlir::Attribute getBackendConfigAttr();
  ::mlir::Attribute getBackendConfig();
  ::mlir::Attribute getApiVersionAttr();
  ::mlir::Attribute getApiVersion();
  ::mlir::Attribute getCalledComputationsAttr();
  ::mlir::Attribute getCalledComputations();
  ::mlir::Attribute getOperandLayoutsAttr();
  ::mlir::Attribute getOperandLayouts();
  ::mlir::Attribute getResultLayoutsAttr();
  ::mlir::Attribute getResultLayouts();
  ::mlir::Attribute getOutputOperandAliasesAttr();
  ::mlir::Attribute getOutputOperandAliases();
};
} // namespace detail
template <typename RangeT>
class CustomCallOpV1GenericAdaptor : public detail::CustomCallOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CustomCallOpV1GenericAdaptorBase;
public:
  CustomCallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CustomCallOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CustomCallOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = CustomCallOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, CustomCallOpV1>>>
  CustomCallOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CustomCallOpV1Adaptor : public CustomCallOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using CustomCallOpV1GenericAdaptor::CustomCallOpV1GenericAdaptor;
  CustomCallOpV1Adaptor(CustomCallOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CustomCallOpV1 : public ::mlir::Op<CustomCallOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CustomCallOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = CustomCallOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("api_version"), ::llvm::StringRef("backend_config"), ::llvm::StringRef("call_target_name"), ::llvm::StringRef("called_computations"), ::llvm::StringRef("has_side_effect"), ::llvm::StringRef("operand_layouts"), ::llvm::StringRef("output_operand_aliases"), ::llvm::StringRef("result_layouts")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getApiVersionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getApiVersionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getBackendConfigAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getBackendConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getCallTargetNameAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getCallTargetNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getCalledComputationsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getCalledComputationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getHasSideEffectAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getHasSideEffectAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getOperandLayoutsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getOperandLayoutsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getOutputOperandAliasesAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getOutputOperandAliasesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getResultLayoutsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getResultLayoutsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.custom_call_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Attribute getCallTargetNameAttr();
  ::mlir::Attribute getCallTargetName();
  ::mlir::Attribute getHasSideEffectAttr();
  ::mlir::Attribute getHasSideEffect();
  ::mlir::Attribute getBackendConfigAttr();
  ::mlir::Attribute getBackendConfig();
  ::mlir::Attribute getApiVersionAttr();
  ::mlir::Attribute getApiVersion();
  ::mlir::Attribute getCalledComputationsAttr();
  ::mlir::Attribute getCalledComputations();
  ::mlir::Attribute getOperandLayoutsAttr();
  ::mlir::Attribute getOperandLayouts();
  ::mlir::Attribute getResultLayoutsAttr();
  ::mlir::Attribute getResultLayouts();
  ::mlir::Attribute getOutputOperandAliasesAttr();
  ::mlir::Attribute getOutputOperandAliases();
  void setCallTargetNameAttr(::mlir::Attribute attr);
  void setHasSideEffectAttr(::mlir::Attribute attr);
  void setBackendConfigAttr(::mlir::Attribute attr);
  void setApiVersionAttr(::mlir::Attribute attr);
  void setCalledComputationsAttr(::mlir::Attribute attr);
  void setOperandLayoutsAttr(::mlir::Attribute attr);
  void setResultLayoutsAttr(::mlir::Attribute attr);
  void setOutputOperandAliasesAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute call_target_name, ::mlir::Attribute has_side_effect, ::mlir::Attribute backend_config, ::mlir::Attribute api_version, ::mlir::Attribute called_computations, ::mlir::Attribute operand_layouts, ::mlir::Attribute result_layouts, ::mlir::Attribute output_operand_aliases);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 8 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::CustomCallOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DivOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DivOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DivOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DivOpV1GenericAdaptorBase(DivOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class DivOpV1GenericAdaptor : public detail::DivOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DivOpV1GenericAdaptorBase;
public:
  DivOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DivOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DivOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DivOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DivOpV1>>>
  DivOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DivOpV1Adaptor : public DivOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DivOpV1GenericAdaptor::DivOpV1GenericAdaptor;
  DivOpV1Adaptor(DivOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DivOpV1 : public ::mlir::Op<DivOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DivOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DivOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.divide_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DivOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotGeneralOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DotGeneralOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DotGeneralOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DotGeneralOpV1GenericAdaptorBase(DotGeneralOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getLhsBatchingDimensionsAttr();
  ::mlir::Attribute getLhsBatchingDimensions();
  ::mlir::Attribute getRhsBatchingDimensionsAttr();
  ::mlir::Attribute getRhsBatchingDimensions();
  ::mlir::Attribute getLhsContractingDimensionsAttr();
  ::mlir::Attribute getLhsContractingDimensions();
  ::mlir::Attribute getRhsContractingDimensionsAttr();
  ::mlir::Attribute getRhsContractingDimensions();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class DotGeneralOpV1GenericAdaptor : public detail::DotGeneralOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DotGeneralOpV1GenericAdaptorBase;
public:
  DotGeneralOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DotGeneralOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DotGeneralOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DotGeneralOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DotGeneralOpV1>>>
  DotGeneralOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DotGeneralOpV1Adaptor : public DotGeneralOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DotGeneralOpV1GenericAdaptor::DotGeneralOpV1GenericAdaptor;
  DotGeneralOpV1Adaptor(DotGeneralOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DotGeneralOpV1 : public ::mlir::Op<DotGeneralOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DotGeneralOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DotGeneralOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("lhs_batching_dimensions"), ::llvm::StringRef("lhs_contracting_dimensions"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_batching_dimensions"), ::llvm::StringRef("rhs_contracting_dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLhsBatchingDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLhsBatchingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getLhsContractingDimensionsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getLhsContractingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getRhsBatchingDimensionsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getRhsBatchingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getRhsContractingDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getRhsContractingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dot_general_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getLhsBatchingDimensionsAttr();
  ::mlir::Attribute getLhsBatchingDimensions();
  ::mlir::Attribute getRhsBatchingDimensionsAttr();
  ::mlir::Attribute getRhsBatchingDimensions();
  ::mlir::Attribute getLhsContractingDimensionsAttr();
  ::mlir::Attribute getLhsContractingDimensions();
  ::mlir::Attribute getRhsContractingDimensionsAttr();
  ::mlir::Attribute getRhsContractingDimensions();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
  void setLhsBatchingDimensionsAttr(::mlir::Attribute attr);
  void setRhsBatchingDimensionsAttr(::mlir::Attribute attr);
  void setLhsContractingDimensionsAttr(::mlir::Attribute attr);
  void setRhsContractingDimensionsAttr(::mlir::Attribute attr);
  void setPrecisionConfigAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute lhs_batching_dimensions, ::mlir::Attribute rhs_batching_dimensions, ::mlir::Attribute lhs_contracting_dimensions, ::mlir::Attribute rhs_contracting_dimensions, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotGeneralOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DotOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DotOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DotOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DotOpV1GenericAdaptorBase(DotOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class DotOpV1GenericAdaptor : public detail::DotOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DotOpV1GenericAdaptorBase;
public:
  DotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DotOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DotOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DotOpV1>>>
  DotOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DotOpV1Adaptor : public DotOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DotOpV1GenericAdaptor::DotOpV1GenericAdaptor;
  DotOpV1Adaptor(DotOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DotOpV1 : public ::mlir::Op<DotOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DotOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DotOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("precision_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dot_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
  void setPrecisionConfigAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DotOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicBroadcastInDimOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicBroadcastInDimOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicBroadcastInDimOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicBroadcastInDimOpV1GenericAdaptorBase(DynamicBroadcastInDimOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getBroadcastDimensionsAttr();
  ::mlir::Attribute getBroadcastDimensions();
  ::mlir::Attribute getKnownExpandingDimensionsAttr();
  ::mlir::Attribute getKnownExpandingDimensions();
  ::mlir::Attribute getKnownNonexpandingDimensionsAttr();
  ::mlir::Attribute getKnownNonexpandingDimensions();
};
} // namespace detail
template <typename RangeT>
class DynamicBroadcastInDimOpV1GenericAdaptor : public detail::DynamicBroadcastInDimOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicBroadcastInDimOpV1GenericAdaptorBase;
public:
  DynamicBroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicBroadcastInDimOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicBroadcastInDimOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicBroadcastInDimOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicBroadcastInDimOpV1>>>
  DynamicBroadcastInDimOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOutputDimensions() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicBroadcastInDimOpV1Adaptor : public DynamicBroadcastInDimOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicBroadcastInDimOpV1GenericAdaptor::DynamicBroadcastInDimOpV1GenericAdaptor;
  DynamicBroadcastInDimOpV1Adaptor(DynamicBroadcastInDimOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicBroadcastInDimOpV1 : public ::mlir::Op<DynamicBroadcastInDimOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicBroadcastInDimOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicBroadcastInDimOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("broadcast_dimensions"), ::llvm::StringRef("known_expanding_dimensions"), ::llvm::StringRef("known_nonexpanding_dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBroadcastDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBroadcastDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getKnownExpandingDimensionsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getKnownExpandingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getKnownNonexpandingDimensionsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getKnownNonexpandingDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_broadcast_in_dim_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getOutputDimensions();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getOutputDimensionsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getBroadcastDimensionsAttr();
  ::mlir::Attribute getBroadcastDimensions();
  ::mlir::Attribute getKnownExpandingDimensionsAttr();
  ::mlir::Attribute getKnownExpandingDimensions();
  ::mlir::Attribute getKnownNonexpandingDimensionsAttr();
  ::mlir::Attribute getKnownNonexpandingDimensions();
  void setBroadcastDimensionsAttr(::mlir::Attribute attr);
  void setKnownExpandingDimensionsAttr(::mlir::Attribute attr);
  void setKnownNonexpandingDimensionsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value output_dimensions, ::mlir::Attribute broadcast_dimensions, ::mlir::Attribute known_expanding_dimensions, ::mlir::Attribute known_nonexpanding_dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value output_dimensions, ::mlir::Attribute broadcast_dimensions, ::mlir::Attribute known_expanding_dimensions, ::mlir::Attribute known_nonexpanding_dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicBroadcastInDimOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicConvOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicConvOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicConvOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicConvOpV1GenericAdaptorBase(DynamicConvOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr();
  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr();
  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr();
  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr();
  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr();
  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr();
  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr();
  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr();
  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr();
  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr();
  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr();
  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr();
  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr();
  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr();
  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class DynamicConvOpV1GenericAdaptor : public detail::DynamicConvOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicConvOpV1GenericAdaptorBase;
public:
  DynamicConvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicConvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicConvOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicConvOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicConvOpV1>>>
  DynamicConvOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  ValueT getDPadding() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicConvOpV1Adaptor : public DynamicConvOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicConvOpV1GenericAdaptor::DynamicConvOpV1GenericAdaptor;
  DynamicConvOpV1Adaptor(DynamicConvOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicConvOpV1 : public ::mlir::Op<DynamicConvOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicConvOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicConvOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_group_count"), ::llvm::StringRef("feature_group_count"), ::llvm::StringRef("input_batch_dimension"), ::llvm::StringRef("input_feature_dimension"), ::llvm::StringRef("input_spatial_dimensions"), ::llvm::StringRef("kernel_input_feature_dimension"), ::llvm::StringRef("kernel_output_feature_dimension"), ::llvm::StringRef("kernel_spatial_dimensions"), ::llvm::StringRef("lhs_dilation"), ::llvm::StringRef("output_batch_dimension"), ::llvm::StringRef("output_feature_dimension"), ::llvm::StringRef("output_spatial_dimensions"), ::llvm::StringRef("padding"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_dilation"), ::llvm::StringRef("window_reversal"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchGroupCountAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureGroupCountAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInputBatchDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getInputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getInputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getKernelInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getKernelInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getKernelSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getKernelSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getLhsDilationAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getLhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getOutputBatchDimensionAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getOutputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getOutputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getOutputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getRhsDilationAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getRhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getWindowReversalAttrName() {
    return getAttributeNameForIndex(15);
  }

  static ::mlir::StringAttr getWindowReversalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 15);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(16);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 16);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_conv_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::Value getDPadding();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  ::mlir::OpOperand &getDPaddingMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  ::mlir::Attribute getLhsDilationAttr();
  ::mlir::Attribute getLhsDilation();
  ::mlir::Attribute getRhsDilationAttr();
  ::mlir::Attribute getRhsDilation();
  ::mlir::Attribute getWindowReversalAttr();
  ::mlir::Attribute getWindowReversal();
  ::mlir::Attribute getInputBatchDimensionAttr();
  ::mlir::Attribute getInputBatchDimension();
  ::mlir::Attribute getInputFeatureDimensionAttr();
  ::mlir::Attribute getInputFeatureDimension();
  ::mlir::Attribute getInputSpatialDimensionsAttr();
  ::mlir::Attribute getInputSpatialDimensions();
  ::mlir::Attribute getKernelInputFeatureDimensionAttr();
  ::mlir::Attribute getKernelInputFeatureDimension();
  ::mlir::Attribute getKernelOutputFeatureDimensionAttr();
  ::mlir::Attribute getKernelOutputFeatureDimension();
  ::mlir::Attribute getKernelSpatialDimensionsAttr();
  ::mlir::Attribute getKernelSpatialDimensions();
  ::mlir::Attribute getOutputBatchDimensionAttr();
  ::mlir::Attribute getOutputBatchDimension();
  ::mlir::Attribute getOutputFeatureDimensionAttr();
  ::mlir::Attribute getOutputFeatureDimension();
  ::mlir::Attribute getOutputSpatialDimensionsAttr();
  ::mlir::Attribute getOutputSpatialDimensions();
  ::mlir::Attribute getFeatureGroupCountAttr();
  ::mlir::Attribute getFeatureGroupCount();
  ::mlir::Attribute getBatchGroupCountAttr();
  ::mlir::Attribute getBatchGroupCount();
  ::mlir::Attribute getPrecisionConfigAttr();
  ::mlir::Attribute getPrecisionConfig();
  void setWindowStridesAttr(::mlir::Attribute attr);
  void setPaddingAttr(::mlir::Attribute attr);
  void setLhsDilationAttr(::mlir::Attribute attr);
  void setRhsDilationAttr(::mlir::Attribute attr);
  void setWindowReversalAttr(::mlir::Attribute attr);
  void setInputBatchDimensionAttr(::mlir::Attribute attr);
  void setInputFeatureDimensionAttr(::mlir::Attribute attr);
  void setInputSpatialDimensionsAttr(::mlir::Attribute attr);
  void setKernelInputFeatureDimensionAttr(::mlir::Attribute attr);
  void setKernelOutputFeatureDimensionAttr(::mlir::Attribute attr);
  void setKernelSpatialDimensionsAttr(::mlir::Attribute attr);
  void setOutputBatchDimensionAttr(::mlir::Attribute attr);
  void setOutputFeatureDimensionAttr(::mlir::Attribute attr);
  void setOutputSpatialDimensionsAttr(::mlir::Attribute attr);
  void setFeatureGroupCountAttr(::mlir::Attribute attr);
  void setBatchGroupCountAttr(::mlir::Attribute attr);
  void setPrecisionConfigAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value d_padding, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value d_padding, ::mlir::Attribute window_strides, ::mlir::Attribute padding, ::mlir::Attribute lhs_dilation, ::mlir::Attribute rhs_dilation, ::mlir::Attribute window_reversal, ::mlir::Attribute input_batch_dimension, ::mlir::Attribute input_feature_dimension, ::mlir::Attribute input_spatial_dimensions, ::mlir::Attribute kernel_input_feature_dimension, ::mlir::Attribute kernel_output_feature_dimension, ::mlir::Attribute kernel_spatial_dimensions, ::mlir::Attribute output_batch_dimension, ::mlir::Attribute output_feature_dimension, ::mlir::Attribute output_spatial_dimensions, ::mlir::Attribute feature_group_count, ::mlir::Attribute batch_group_count, ::mlir::Attribute precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 17 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicConvOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicGatherOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicGatherOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicGatherOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicGatherOpV1GenericAdaptorBase(DynamicGatherOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getOffsetDimsAttr();
  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr();
  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr();
  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr();
  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr();
  ::mlir::Attribute getIndicesAreSorted();
};
} // namespace detail
template <typename RangeT>
class DynamicGatherOpV1GenericAdaptor : public detail::DynamicGatherOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicGatherOpV1GenericAdaptorBase;
public:
  DynamicGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicGatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicGatherOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicGatherOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicGatherOpV1>>>
  DynamicGatherOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  ValueT getSliceSizes() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicGatherOpV1Adaptor : public DynamicGatherOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicGatherOpV1GenericAdaptor::DynamicGatherOpV1GenericAdaptor;
  DynamicGatherOpV1Adaptor(DynamicGatherOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicGatherOpV1 : public ::mlir::Op<DynamicGatherOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicGatherOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicGatherOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("collapsed_slice_dims"), ::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("offset_dims"), ::llvm::StringRef("start_index_map")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCollapsedSliceDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCollapsedSliceDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOffsetDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getOffsetDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getStartIndexMapAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getStartIndexMapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_gather_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getStartIndices();
  ::mlir::Value getSliceSizes();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getStartIndicesMutable();
  ::mlir::OpOperand &getSliceSizesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getOffsetDimsAttr();
  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr();
  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr();
  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr();
  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr();
  ::mlir::Attribute getIndicesAreSorted();
  void setOffsetDimsAttr(::mlir::Attribute attr);
  void setCollapsedSliceDimsAttr(::mlir::Attribute attr);
  void setStartIndexMapAttr(::mlir::Attribute attr);
  void setIndexVectorDimAttr(::mlir::Attribute attr);
  void setIndicesAreSortedAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value slice_sizes, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicGatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicIotaOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicIotaOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicIotaOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicIotaOpV1GenericAdaptorBase(DynamicIotaOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getIotaDimensionAttr();
  ::mlir::Attribute getIotaDimension();
};
} // namespace detail
template <typename RangeT>
class DynamicIotaOpV1GenericAdaptor : public detail::DynamicIotaOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicIotaOpV1GenericAdaptorBase;
public:
  DynamicIotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicIotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicIotaOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicIotaOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicIotaOpV1>>>
  DynamicIotaOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOutputShape() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicIotaOpV1Adaptor : public DynamicIotaOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicIotaOpV1GenericAdaptor::DynamicIotaOpV1GenericAdaptor;
  DynamicIotaOpV1Adaptor(DynamicIotaOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicIotaOpV1 : public ::mlir::Op<DynamicIotaOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicIotaOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicIotaOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("iota_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIotaDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIotaDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_iota_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOutputShape();
  ::mlir::OpOperand &getOutputShapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getIotaDimensionAttr();
  ::mlir::Attribute getIotaDimension();
  void setIotaDimensionAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value output_shape, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value output_shape, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicIotaOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicPadOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicPadOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicPadOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicPadOpV1GenericAdaptorBase(DynamicPadOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class DynamicPadOpV1GenericAdaptor : public detail::DynamicPadOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicPadOpV1GenericAdaptorBase;
public:
  DynamicPadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicPadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicPadOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicPadOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicPadOpV1>>>
  DynamicPadOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getPaddingValue() {
    return (*getODSOperands(1).begin());
  }

  ValueT getEdgePaddingLow() {
    return (*getODSOperands(2).begin());
  }

  ValueT getEdgePaddingHigh() {
    return (*getODSOperands(3).begin());
  }

  ValueT getInteriorPadding() {
    return (*getODSOperands(4).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicPadOpV1Adaptor : public DynamicPadOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicPadOpV1GenericAdaptor::DynamicPadOpV1GenericAdaptor;
  DynamicPadOpV1Adaptor(DynamicPadOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicPadOpV1 : public ::mlir::Op<DynamicPadOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<5>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicPadOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicPadOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_pad_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getPaddingValue();
  ::mlir::Value getEdgePaddingLow();
  ::mlir::Value getEdgePaddingHigh();
  ::mlir::Value getInteriorPadding();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getPaddingValueMutable();
  ::mlir::OpOperand &getEdgePaddingLowMutable();
  ::mlir::OpOperand &getEdgePaddingHighMutable();
  ::mlir::OpOperand &getInteriorPaddingMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Value edge_padding_low, ::mlir::Value edge_padding_high, ::mlir::Value interior_padding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Value edge_padding_low, ::mlir::Value edge_padding_high, ::mlir::Value interior_padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicPadOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicReshapeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicReshapeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicReshapeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicReshapeOpV1GenericAdaptorBase(DynamicReshapeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class DynamicReshapeOpV1GenericAdaptor : public detail::DynamicReshapeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicReshapeOpV1GenericAdaptorBase;
public:
  DynamicReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicReshapeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicReshapeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicReshapeOpV1>>>
  DynamicReshapeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOutputShape() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicReshapeOpV1Adaptor : public DynamicReshapeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicReshapeOpV1GenericAdaptor::DynamicReshapeOpV1GenericAdaptor;
  DynamicReshapeOpV1Adaptor(DynamicReshapeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicReshapeOpV1 : public ::mlir::Op<DynamicReshapeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicReshapeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicReshapeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_reshape_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getOutputShape();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getOutputShapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value output_shape);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value output_shape);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicReshapeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicSliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicSliceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicSliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicSliceOpV1GenericAdaptorBase(DynamicSliceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getSliceSizesAttr();
  ::mlir::Attribute getSliceSizes();
};
} // namespace detail
template <typename RangeT>
class DynamicSliceOpV1GenericAdaptor : public detail::DynamicSliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicSliceOpV1GenericAdaptorBase;
public:
  DynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicSliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicSliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicSliceOpV1>>>
  DynamicSliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getStartIndices() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicSliceOpV1Adaptor : public DynamicSliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicSliceOpV1GenericAdaptor::DynamicSliceOpV1GenericAdaptor;
  DynamicSliceOpV1Adaptor(DynamicSliceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicSliceOpV1 : public ::mlir::Op<DynamicSliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicSliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicSliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("slice_sizes")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getSliceSizesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getSliceSizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Operation::operand_range getStartIndices();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::MutableOperandRange getStartIndicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getSliceSizesAttr();
  ::mlir::Attribute getSliceSizes();
  void setSliceSizesAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::ValueRange start_indices, ::mlir::Attribute slice_sizes);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::ValueRange start_indices, ::mlir::Attribute slice_sizes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::DynamicUpdateSliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class DynamicUpdateSliceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  DynamicUpdateSliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  DynamicUpdateSliceOpV1GenericAdaptorBase(DynamicUpdateSliceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class DynamicUpdateSliceOpV1GenericAdaptor : public detail::DynamicUpdateSliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::DynamicUpdateSliceOpV1GenericAdaptorBase;
public:
  DynamicUpdateSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  DynamicUpdateSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : DynamicUpdateSliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = DynamicUpdateSliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, DynamicUpdateSliceOpV1>>>
  DynamicUpdateSliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getUpdate() {
    return (*getODSOperands(1).begin());
  }

  RangeT getStartIndices() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class DynamicUpdateSliceOpV1Adaptor : public DynamicUpdateSliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using DynamicUpdateSliceOpV1GenericAdaptor::DynamicUpdateSliceOpV1GenericAdaptor;
  DynamicUpdateSliceOpV1Adaptor(DynamicUpdateSliceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class DynamicUpdateSliceOpV1 : public ::mlir::Op<DynamicUpdateSliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = DynamicUpdateSliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = DynamicUpdateSliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.dynamic_update_slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getUpdate();
  ::mlir::Operation::operand_range getStartIndices();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getUpdateMutable();
  ::mlir::MutableOperandRange getStartIndicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value update, ::mlir::ValueRange start_indices);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value update, ::mlir::ValueRange start_indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::DynamicUpdateSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::EinsumOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class EinsumOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  EinsumOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  EinsumOpV1GenericAdaptorBase(EinsumOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getEinsumConfigAttr();
  ::mlir::Attribute getEinsumConfig();
};
} // namespace detail
template <typename RangeT>
class EinsumOpV1GenericAdaptor : public detail::EinsumOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::EinsumOpV1GenericAdaptorBase;
public:
  EinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  EinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : EinsumOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = EinsumOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, EinsumOpV1>>>
  EinsumOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class EinsumOpV1Adaptor : public EinsumOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using EinsumOpV1GenericAdaptor::EinsumOpV1GenericAdaptor;
  EinsumOpV1Adaptor(EinsumOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class EinsumOpV1 : public ::mlir::Op<EinsumOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = EinsumOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = EinsumOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("einsum_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEinsumConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEinsumConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.einsum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getEinsumConfigAttr();
  ::mlir::Attribute getEinsumConfig();
  void setEinsumConfigAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::EinsumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ExpOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ExpOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ExpOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ExpOpV1GenericAdaptorBase(ExpOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ExpOpV1GenericAdaptor : public detail::ExpOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ExpOpV1GenericAdaptorBase;
public:
  ExpOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ExpOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ExpOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ExpOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ExpOpV1>>>
  ExpOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ExpOpV1Adaptor : public ExpOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ExpOpV1GenericAdaptor::ExpOpV1GenericAdaptor;
  ExpOpV1Adaptor(ExpOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ExpOpV1 : public ::mlir::Op<ExpOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ExpOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ExpOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.exponential_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ExpOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Expm1OpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class Expm1OpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  Expm1OpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  Expm1OpV1GenericAdaptorBase(Expm1OpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class Expm1OpV1GenericAdaptor : public detail::Expm1OpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::Expm1OpV1GenericAdaptorBase;
public:
  Expm1OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  Expm1OpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : Expm1OpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = Expm1OpV1, typename = std::enable_if_t<std::is_same_v<LateInst, Expm1OpV1>>>
  Expm1OpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class Expm1OpV1Adaptor : public Expm1OpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using Expm1OpV1GenericAdaptor::Expm1OpV1GenericAdaptor;
  Expm1OpV1Adaptor(Expm1OpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class Expm1OpV1 : public ::mlir::Op<Expm1OpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Expm1OpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = Expm1OpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.exponential_minus_one_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::Expm1OpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FftOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FftOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  FftOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  FftOpV1GenericAdaptorBase(FftOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getFftTypeAttr();
  ::mlir::Attribute getFftType();
  ::mlir::Attribute getFftLengthAttr();
  ::mlir::Attribute getFftLength();
};
} // namespace detail
template <typename RangeT>
class FftOpV1GenericAdaptor : public detail::FftOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FftOpV1GenericAdaptorBase;
public:
  FftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FftOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = FftOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, FftOpV1>>>
  FftOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FftOpV1Adaptor : public FftOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using FftOpV1GenericAdaptor::FftOpV1GenericAdaptor;
  FftOpV1Adaptor(FftOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class FftOpV1 : public ::mlir::Op<FftOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FftOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = FftOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("fft_length"), ::llvm::StringRef("fft_type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getFftLengthAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getFftLengthAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFftTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFftTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.fft_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getFftTypeAttr();
  ::mlir::Attribute getFftType();
  ::mlir::Attribute getFftLengthAttr();
  ::mlir::Attribute getFftLength();
  void setFftTypeAttr(::mlir::Attribute attr);
  void setFftLengthAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute fft_type, ::mlir::Attribute fft_length);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute fft_type, ::mlir::Attribute fft_length);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::FftOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FloorOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FloorOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  FloorOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  FloorOpV1GenericAdaptorBase(FloorOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class FloorOpV1GenericAdaptor : public detail::FloorOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FloorOpV1GenericAdaptorBase;
public:
  FloorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FloorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FloorOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = FloorOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, FloorOpV1>>>
  FloorOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FloorOpV1Adaptor : public FloorOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using FloorOpV1GenericAdaptor::FloorOpV1GenericAdaptor;
  FloorOpV1Adaptor(FloorOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class FloorOpV1 : public ::mlir::Op<FloorOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FloorOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = FloorOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.floor_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::FloorOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::FuncOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FuncOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  FuncOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  FuncOpV1GenericAdaptorBase(FuncOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getSymNameAttr();
  ::mlir::Attribute getSymName();
  ::mlir::Attribute getFunctionTypeAttr();
  ::mlir::Attribute getFunctionType();
  ::mlir::Attribute getSymVisibilityAttr();
  ::mlir::Attribute getSymVisibility();
  ::mlir::Attribute getArgAttrsAttr();
  ::mlir::Attribute getArgAttrs();
  ::mlir::Attribute getResAttrsAttr();
  ::mlir::Attribute getResAttrs();
  ::mlir::Region &getBody();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class FuncOpV1GenericAdaptor : public detail::FuncOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FuncOpV1GenericAdaptorBase;
public:
  FuncOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FuncOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FuncOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = FuncOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, FuncOpV1>>>
  FuncOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FuncOpV1Adaptor : public FuncOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using FuncOpV1GenericAdaptor::FuncOpV1GenericAdaptor;
  FuncOpV1Adaptor(FuncOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class FuncOpV1 : public ::mlir::Op<FuncOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FuncOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = FuncOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("arg_attrs"), ::llvm::StringRef("function_type"), ::llvm::StringRef("res_attrs"), ::llvm::StringRef("sym_name"), ::llvm::StringRef("sym_visibility")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getArgAttrsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getArgAttrsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFunctionTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFunctionTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getResAttrsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getResAttrsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getSymNameAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getSymNameAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSymVisibilityAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSymVisibilityAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.func_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Region &getBody();
  ::mlir::Attribute getSymNameAttr();
  ::mlir::Attribute getSymName();
  ::mlir::Attribute getFunctionTypeAttr();
  ::mlir::Attribute getFunctionType();
  ::mlir::Attribute getSymVisibilityAttr();
  ::mlir::Attribute getSymVisibility();
  ::mlir::Attribute getArgAttrsAttr();
  ::mlir::Attribute getArgAttrs();
  ::mlir::Attribute getResAttrsAttr();
  ::mlir::Attribute getResAttrs();
  void setSymNameAttr(::mlir::Attribute attr);
  void setFunctionTypeAttr(::mlir::Attribute attr);
  void setSymVisibilityAttr(::mlir::Attribute attr);
  void setArgAttrsAttr(::mlir::Attribute attr);
  void setResAttrsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Attribute sym_name, ::mlir::Attribute function_type, ::mlir::Attribute sym_visibility, ::mlir::Attribute arg_attrs, ::mlir::Attribute res_attrs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute sym_name, ::mlir::Attribute function_type, ::mlir::Attribute sym_visibility, ::mlir::Attribute arg_attrs, ::mlir::Attribute res_attrs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::FuncOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GatherOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GatherOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  GatherOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  GatherOpV1GenericAdaptorBase(GatherOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getOffsetDimsAttr();
  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr();
  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr();
  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr();
  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getSliceSizesAttr();
  ::mlir::Attribute getSliceSizes();
  ::mlir::Attribute getIndicesAreSortedAttr();
  ::mlir::Attribute getIndicesAreSorted();
};
} // namespace detail
template <typename RangeT>
class GatherOpV1GenericAdaptor : public detail::GatherOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GatherOpV1GenericAdaptorBase;
public:
  GatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GatherOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GatherOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = GatherOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, GatherOpV1>>>
  GatherOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GatherOpV1Adaptor : public GatherOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using GatherOpV1GenericAdaptor::GatherOpV1GenericAdaptor;
  GatherOpV1Adaptor(GatherOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class GatherOpV1 : public ::mlir::Op<GatherOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GatherOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = GatherOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("collapsed_slice_dims"), ::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("offset_dims"), ::llvm::StringRef("slice_sizes"), ::llvm::StringRef("start_index_map")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getCollapsedSliceDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getCollapsedSliceDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getOffsetDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getOffsetDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSliceSizesAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSliceSizesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getStartIndexMapAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getStartIndexMapAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.gather_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getStartIndices();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getStartIndicesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getOffsetDimsAttr();
  ::mlir::Attribute getOffsetDims();
  ::mlir::Attribute getCollapsedSliceDimsAttr();
  ::mlir::Attribute getCollapsedSliceDims();
  ::mlir::Attribute getStartIndexMapAttr();
  ::mlir::Attribute getStartIndexMap();
  ::mlir::Attribute getIndexVectorDimAttr();
  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getSliceSizesAttr();
  ::mlir::Attribute getSliceSizes();
  ::mlir::Attribute getIndicesAreSortedAttr();
  ::mlir::Attribute getIndicesAreSorted();
  void setOffsetDimsAttr(::mlir::Attribute attr);
  void setCollapsedSliceDimsAttr(::mlir::Attribute attr);
  void setStartIndexMapAttr(::mlir::Attribute attr);
  void setIndexVectorDimAttr(::mlir::Attribute attr);
  void setSliceSizesAttr(::mlir::Attribute attr);
  void setIndicesAreSortedAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Attribute offset_dims, ::mlir::Attribute collapsed_slice_dims, ::mlir::Attribute start_index_map, ::mlir::Attribute index_vector_dim, ::mlir::Attribute slice_sizes, ::mlir::Attribute indices_are_sorted);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 6 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::GatherOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GetDimensionSizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GetDimensionSizeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  GetDimensionSizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  GetDimensionSizeOpV1GenericAdaptorBase(GetDimensionSizeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
};
} // namespace detail
template <typename RangeT>
class GetDimensionSizeOpV1GenericAdaptor : public detail::GetDimensionSizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GetDimensionSizeOpV1GenericAdaptorBase;
public:
  GetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GetDimensionSizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = GetDimensionSizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, GetDimensionSizeOpV1>>>
  GetDimensionSizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GetDimensionSizeOpV1Adaptor : public GetDimensionSizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using GetDimensionSizeOpV1GenericAdaptor::GetDimensionSizeOpV1GenericAdaptor;
  GetDimensionSizeOpV1Adaptor(GetDimensionSizeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class GetDimensionSizeOpV1 : public ::mlir::Op<GetDimensionSizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GetDimensionSizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = GetDimensionSizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.get_dimension_size_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
  void setDimensionAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::GetDimensionSizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::GetTupleElementOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class GetTupleElementOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  GetTupleElementOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  GetTupleElementOpV1GenericAdaptorBase(GetTupleElementOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getIndexAttr();
  ::mlir::Attribute getIndex();
};
} // namespace detail
template <typename RangeT>
class GetTupleElementOpV1GenericAdaptor : public detail::GetTupleElementOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::GetTupleElementOpV1GenericAdaptorBase;
public:
  GetTupleElementOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  GetTupleElementOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : GetTupleElementOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = GetTupleElementOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, GetTupleElementOpV1>>>
  GetTupleElementOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class GetTupleElementOpV1Adaptor : public GetTupleElementOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using GetTupleElementOpV1GenericAdaptor::GetTupleElementOpV1GenericAdaptor;
  GetTupleElementOpV1Adaptor(GetTupleElementOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class GetTupleElementOpV1 : public ::mlir::Op<GetTupleElementOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = GetTupleElementOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = GetTupleElementOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("index")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIndexAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIndexAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.get_tuple_element_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getIndexAttr();
  ::mlir::Attribute getIndex();
  void setIndexAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute index);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::GetTupleElementOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IfOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class IfOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  IfOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  IfOpV1GenericAdaptorBase(IfOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Region &getTrueBranch();
  ::mlir::Region &getFalseBranch();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class IfOpV1GenericAdaptor : public detail::IfOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::IfOpV1GenericAdaptorBase;
public:
  IfOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  IfOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : IfOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = IfOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, IfOpV1>>>
  IfOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getPred() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class IfOpV1Adaptor : public IfOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using IfOpV1GenericAdaptor::IfOpV1GenericAdaptor;
  IfOpV1Adaptor(IfOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class IfOpV1 : public ::mlir::Op<IfOpV1, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = IfOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = IfOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.if_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getPred();
  ::mlir::OpOperand &getPredMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Region &getTrueBranch();
  ::mlir::Region &getFalseBranch();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value pred);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::IfOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ImagOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ImagOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ImagOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ImagOpV1GenericAdaptorBase(ImagOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ImagOpV1GenericAdaptor : public detail::ImagOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ImagOpV1GenericAdaptorBase;
public:
  ImagOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ImagOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ImagOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ImagOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ImagOpV1>>>
  ImagOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ImagOpV1Adaptor : public ImagOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ImagOpV1GenericAdaptor::ImagOpV1GenericAdaptor;
  ImagOpV1Adaptor(ImagOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ImagOpV1 : public ::mlir::Op<ImagOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ImagOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ImagOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.imag_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ImagOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::InfeedOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class InfeedOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  InfeedOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  InfeedOpV1GenericAdaptorBase(InfeedOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getInfeedConfigAttr();
  ::mlir::Attribute getInfeedConfig();
  ::mlir::Attribute getLayoutAttr();
  ::mlir::Attribute getLayout();
};
} // namespace detail
template <typename RangeT>
class InfeedOpV1GenericAdaptor : public detail::InfeedOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::InfeedOpV1GenericAdaptorBase;
public:
  InfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  InfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : InfeedOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = InfeedOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, InfeedOpV1>>>
  InfeedOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getToken() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class InfeedOpV1Adaptor : public InfeedOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using InfeedOpV1GenericAdaptor::InfeedOpV1GenericAdaptor;
  InfeedOpV1Adaptor(InfeedOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class InfeedOpV1 : public ::mlir::Op<InfeedOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = InfeedOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = InfeedOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("infeed_config"), ::llvm::StringRef("layout")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getInfeedConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getInfeedConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getLayoutAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getLayoutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.infeed_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getToken();
  ::mlir::OpOperand &getTokenMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Attribute getInfeedConfigAttr();
  ::mlir::Attribute getInfeedConfig();
  ::mlir::Attribute getLayoutAttr();
  ::mlir::Attribute getLayout();
  void setInfeedConfigAttr(::mlir::Attribute attr);
  void setLayoutAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value token, ::mlir::Attribute infeed_config, ::mlir::Attribute layout);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::InfeedOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IotaOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class IotaOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  IotaOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  IotaOpV1GenericAdaptorBase(IotaOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getIotaDimensionAttr();
  ::mlir::Attribute getIotaDimension();
};
} // namespace detail
template <typename RangeT>
class IotaOpV1GenericAdaptor : public detail::IotaOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::IotaOpV1GenericAdaptorBase;
public:
  IotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  IotaOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : IotaOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = IotaOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, IotaOpV1>>>
  IotaOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class IotaOpV1Adaptor : public IotaOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using IotaOpV1GenericAdaptor::IotaOpV1GenericAdaptor;
  IotaOpV1Adaptor(IotaOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class IotaOpV1 : public ::mlir::Op<IotaOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = IotaOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = IotaOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("iota_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIotaDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIotaDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.iota_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getOutput();
  ::mlir::Attribute getIotaDimensionAttr();
  ::mlir::Attribute getIotaDimension();
  void setIotaDimensionAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute iota_dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::IotaOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::IsFiniteOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class IsFiniteOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  IsFiniteOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  IsFiniteOpV1GenericAdaptorBase(IsFiniteOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class IsFiniteOpV1GenericAdaptor : public detail::IsFiniteOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::IsFiniteOpV1GenericAdaptorBase;
public:
  IsFiniteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  IsFiniteOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : IsFiniteOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = IsFiniteOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, IsFiniteOpV1>>>
  IsFiniteOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getX() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class IsFiniteOpV1Adaptor : public IsFiniteOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using IsFiniteOpV1GenericAdaptor::IsFiniteOpV1GenericAdaptor;
  IsFiniteOpV1Adaptor(IsFiniteOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class IsFiniteOpV1 : public ::mlir::Op<IsFiniteOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = IsFiniteOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = IsFiniteOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.is_finite_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getX();
  ::mlir::OpOperand &getXMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getY();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::IsFiniteOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::Log1pOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class Log1pOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  Log1pOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  Log1pOpV1GenericAdaptorBase(Log1pOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class Log1pOpV1GenericAdaptor : public detail::Log1pOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::Log1pOpV1GenericAdaptorBase;
public:
  Log1pOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  Log1pOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : Log1pOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = Log1pOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, Log1pOpV1>>>
  Log1pOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class Log1pOpV1Adaptor : public Log1pOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using Log1pOpV1GenericAdaptor::Log1pOpV1GenericAdaptor;
  Log1pOpV1Adaptor(Log1pOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class Log1pOpV1 : public ::mlir::Op<Log1pOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = Log1pOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = Log1pOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.log_plus_one_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::Log1pOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::LogOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class LogOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  LogOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  LogOpV1GenericAdaptorBase(LogOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class LogOpV1GenericAdaptor : public detail::LogOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::LogOpV1GenericAdaptorBase;
public:
  LogOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  LogOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : LogOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = LogOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, LogOpV1>>>
  LogOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class LogOpV1Adaptor : public LogOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using LogOpV1GenericAdaptor::LogOpV1GenericAdaptor;
  LogOpV1Adaptor(LogOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class LogOpV1 : public ::mlir::Op<LogOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = LogOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = LogOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.log_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::LogOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::LogisticOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class LogisticOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  LogisticOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  LogisticOpV1GenericAdaptorBase(LogisticOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class LogisticOpV1GenericAdaptor : public detail::LogisticOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::LogisticOpV1GenericAdaptorBase;
public:
  LogisticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  LogisticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : LogisticOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = LogisticOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, LogisticOpV1>>>
  LogisticOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class LogisticOpV1Adaptor : public LogisticOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using LogisticOpV1GenericAdaptor::LogisticOpV1GenericAdaptor;
  LogisticOpV1Adaptor(LogisticOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class LogisticOpV1 : public ::mlir::Op<LogisticOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = LogisticOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = LogisticOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.logistic_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::LogisticOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MapOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MapOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MapOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  MapOpV1GenericAdaptorBase(MapOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimensionsAttr();
  ::mlir::Attribute getDimensions();
  ::mlir::Region &getComputation();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class MapOpV1GenericAdaptor : public detail::MapOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MapOpV1GenericAdaptorBase;
public:
  MapOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MapOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MapOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MapOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MapOpV1>>>
  MapOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MapOpV1Adaptor : public MapOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MapOpV1GenericAdaptor::MapOpV1GenericAdaptor;
  MapOpV1Adaptor(MapOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class MapOpV1 : public ::mlir::Op<MapOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MapOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MapOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.map_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Region &getComputation();
  ::mlir::Attribute getDimensionsAttr();
  ::mlir::Attribute getDimensions();
  void setDimensionsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MapOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MaxOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MaxOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MaxOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  MaxOpV1GenericAdaptorBase(MaxOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class MaxOpV1GenericAdaptor : public detail::MaxOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MaxOpV1GenericAdaptorBase;
public:
  MaxOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MaxOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MaxOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MaxOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MaxOpV1>>>
  MaxOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MaxOpV1Adaptor : public MaxOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MaxOpV1GenericAdaptor::MaxOpV1GenericAdaptor;
  MaxOpV1Adaptor(MaxOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class MaxOpV1 : public ::mlir::Op<MaxOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MaxOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MaxOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.maximum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MaxOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MinOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MinOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MinOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  MinOpV1GenericAdaptorBase(MinOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class MinOpV1GenericAdaptor : public detail::MinOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MinOpV1GenericAdaptorBase;
public:
  MinOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MinOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MinOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MinOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MinOpV1>>>
  MinOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MinOpV1Adaptor : public MinOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MinOpV1GenericAdaptor::MinOpV1GenericAdaptor;
  MinOpV1Adaptor(MinOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class MinOpV1 : public ::mlir::Op<MinOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MinOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MinOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.minimum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MinOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::MulOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MulOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MulOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  MulOpV1GenericAdaptorBase(MulOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class MulOpV1GenericAdaptor : public detail::MulOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MulOpV1GenericAdaptorBase;
public:
  MulOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MulOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MulOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MulOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, MulOpV1>>>
  MulOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MulOpV1Adaptor : public MulOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using MulOpV1GenericAdaptor::MulOpV1GenericAdaptor;
  MulOpV1Adaptor(MulOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class MulOpV1 : public ::mlir::Op<MulOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MulOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = MulOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.multiply_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::MulOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::NegOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class NegOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  NegOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  NegOpV1GenericAdaptorBase(NegOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class NegOpV1GenericAdaptor : public detail::NegOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::NegOpV1GenericAdaptorBase;
public:
  NegOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  NegOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : NegOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = NegOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, NegOpV1>>>
  NegOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class NegOpV1Adaptor : public NegOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using NegOpV1GenericAdaptor::NegOpV1GenericAdaptor;
  NegOpV1Adaptor(NegOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class NegOpV1 : public ::mlir::Op<NegOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NegOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = NegOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.negate_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::NegOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::NotOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class NotOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  NotOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  NotOpV1GenericAdaptorBase(NotOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class NotOpV1GenericAdaptor : public detail::NotOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::NotOpV1GenericAdaptorBase;
public:
  NotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  NotOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : NotOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = NotOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, NotOpV1>>>
  NotOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class NotOpV1Adaptor : public NotOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using NotOpV1GenericAdaptor::NotOpV1GenericAdaptor;
  NotOpV1Adaptor(NotOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class NotOpV1 : public ::mlir::Op<NotOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = NotOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = NotOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.not_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::NotOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OptimizationBarrierOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OptimizationBarrierOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  OptimizationBarrierOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  OptimizationBarrierOpV1GenericAdaptorBase(OptimizationBarrierOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class OptimizationBarrierOpV1GenericAdaptor : public detail::OptimizationBarrierOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OptimizationBarrierOpV1GenericAdaptorBase;
public:
  OptimizationBarrierOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OptimizationBarrierOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OptimizationBarrierOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = OptimizationBarrierOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, OptimizationBarrierOpV1>>>
  OptimizationBarrierOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperand() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OptimizationBarrierOpV1Adaptor : public OptimizationBarrierOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using OptimizationBarrierOpV1GenericAdaptor::OptimizationBarrierOpV1GenericAdaptor;
  OptimizationBarrierOpV1Adaptor(OptimizationBarrierOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class OptimizationBarrierOpV1 : public ::mlir::Op<OptimizationBarrierOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OptimizationBarrierOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = OptimizationBarrierOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.optimization_barrier_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getOperand();
  ::mlir::MutableOperandRange getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResult();
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::OptimizationBarrierOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OrOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OrOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  OrOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  OrOpV1GenericAdaptorBase(OrOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class OrOpV1GenericAdaptor : public detail::OrOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OrOpV1GenericAdaptorBase;
public:
  OrOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OrOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OrOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = OrOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, OrOpV1>>>
  OrOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OrOpV1Adaptor : public OrOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using OrOpV1GenericAdaptor::OrOpV1GenericAdaptor;
  OrOpV1Adaptor(OrOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class OrOpV1 : public ::mlir::Op<OrOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OrOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = OrOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.or_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::OrOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::OutfeedOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OutfeedOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  OutfeedOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  OutfeedOpV1GenericAdaptorBase(OutfeedOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getOutfeedConfigAttr();
  ::mlir::Attribute getOutfeedConfig();
};
} // namespace detail
template <typename RangeT>
class OutfeedOpV1GenericAdaptor : public detail::OutfeedOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OutfeedOpV1GenericAdaptorBase;
public:
  OutfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OutfeedOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OutfeedOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = OutfeedOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, OutfeedOpV1>>>
  OutfeedOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  ValueT getToken() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OutfeedOpV1Adaptor : public OutfeedOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using OutfeedOpV1GenericAdaptor::OutfeedOpV1GenericAdaptor;
  OutfeedOpV1Adaptor(OutfeedOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class OutfeedOpV1 : public ::mlir::Op<OutfeedOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OutfeedOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = OutfeedOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("outfeed_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getOutfeedConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getOutfeedConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.outfeed_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::Value getToken();
  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::OpOperand &getTokenMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getOutfeedConfigAttr();
  ::mlir::Attribute getOutfeedConfig();
  void setOutfeedConfigAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute outfeed_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute outfeed_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::OutfeedOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PadOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PadOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PadOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  PadOpV1GenericAdaptorBase(PadOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getEdgePaddingLowAttr();
  ::mlir::Attribute getEdgePaddingLow();
  ::mlir::Attribute getEdgePaddingHighAttr();
  ::mlir::Attribute getEdgePaddingHigh();
  ::mlir::Attribute getInteriorPaddingAttr();
  ::mlir::Attribute getInteriorPadding();
};
} // namespace detail
template <typename RangeT>
class PadOpV1GenericAdaptor : public detail::PadOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PadOpV1GenericAdaptorBase;
public:
  PadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PadOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PadOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PadOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PadOpV1>>>
  PadOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getPaddingValue() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PadOpV1Adaptor : public PadOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PadOpV1GenericAdaptor::PadOpV1GenericAdaptor;
  PadOpV1Adaptor(PadOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PadOpV1 : public ::mlir::Op<PadOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PadOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PadOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("edge_padding_high"), ::llvm::StringRef("edge_padding_low"), ::llvm::StringRef("interior_padding")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEdgePaddingHighAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEdgePaddingHighAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getEdgePaddingLowAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getEdgePaddingLowAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInteriorPaddingAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInteriorPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.pad_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getPaddingValue();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getPaddingValueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getEdgePaddingLowAttr();
  ::mlir::Attribute getEdgePaddingLow();
  ::mlir::Attribute getEdgePaddingHighAttr();
  ::mlir::Attribute getEdgePaddingHigh();
  ::mlir::Attribute getInteriorPaddingAttr();
  ::mlir::Attribute getInteriorPadding();
  void setEdgePaddingLowAttr(::mlir::Attribute attr);
  void setEdgePaddingHighAttr(::mlir::Attribute attr);
  void setInteriorPaddingAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Attribute edge_padding_low, ::mlir::Attribute edge_padding_high, ::mlir::Attribute interior_padding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value padding_value, ::mlir::Attribute edge_padding_low, ::mlir::Attribute edge_padding_high, ::mlir::Attribute interior_padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PadOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PartitionIdOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PartitionIdOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PartitionIdOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  PartitionIdOpV1GenericAdaptorBase(PartitionIdOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class PartitionIdOpV1GenericAdaptor : public detail::PartitionIdOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PartitionIdOpV1GenericAdaptorBase;
public:
  PartitionIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PartitionIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PartitionIdOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PartitionIdOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PartitionIdOpV1>>>
  PartitionIdOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PartitionIdOpV1Adaptor : public PartitionIdOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PartitionIdOpV1GenericAdaptor::PartitionIdOpV1GenericAdaptor;
  PartitionIdOpV1Adaptor(PartitionIdOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PartitionIdOpV1 : public ::mlir::Op<PartitionIdOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PartitionIdOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PartitionIdOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.partition_id_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PartitionIdOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PopulationCountOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PopulationCountOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PopulationCountOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  PopulationCountOpV1GenericAdaptorBase(PopulationCountOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class PopulationCountOpV1GenericAdaptor : public detail::PopulationCountOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PopulationCountOpV1GenericAdaptorBase;
public:
  PopulationCountOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PopulationCountOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PopulationCountOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PopulationCountOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PopulationCountOpV1>>>
  PopulationCountOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PopulationCountOpV1Adaptor : public PopulationCountOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PopulationCountOpV1GenericAdaptor::PopulationCountOpV1GenericAdaptor;
  PopulationCountOpV1Adaptor(PopulationCountOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PopulationCountOpV1 : public ::mlir::Op<PopulationCountOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PopulationCountOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PopulationCountOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.popcnt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PopulationCountOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::PowOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PowOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PowOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  PowOpV1GenericAdaptorBase(PowOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class PowOpV1GenericAdaptor : public detail::PowOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PowOpV1GenericAdaptorBase;
public:
  PowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PowOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PowOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, PowOpV1>>>
  PowOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PowOpV1Adaptor : public PowOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using PowOpV1GenericAdaptor::PowOpV1GenericAdaptor;
  PowOpV1Adaptor(PowOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PowOpV1 : public ::mlir::Op<PowOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PowOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = PowOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.power_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::PowOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RealDynamicSliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RealDynamicSliceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RealDynamicSliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RealDynamicSliceOpV1GenericAdaptorBase(RealDynamicSliceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class RealDynamicSliceOpV1GenericAdaptor : public detail::RealDynamicSliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RealDynamicSliceOpV1GenericAdaptorBase;
public:
  RealDynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RealDynamicSliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RealDynamicSliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RealDynamicSliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RealDynamicSliceOpV1>>>
  RealDynamicSliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getStartIndices() {
    return (*getODSOperands(1).begin());
  }

  ValueT getLimitIndices() {
    return (*getODSOperands(2).begin());
  }

  ValueT getStrides() {
    return (*getODSOperands(3).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RealDynamicSliceOpV1Adaptor : public RealDynamicSliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RealDynamicSliceOpV1GenericAdaptor::RealDynamicSliceOpV1GenericAdaptor;
  RealDynamicSliceOpV1Adaptor(RealDynamicSliceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RealDynamicSliceOpV1 : public ::mlir::Op<RealDynamicSliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<4>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RealDynamicSliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RealDynamicSliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.real_dynamic_slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getStartIndices();
  ::mlir::Value getLimitIndices();
  ::mlir::Value getStrides();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getStartIndicesMutable();
  ::mlir::OpOperand &getLimitIndicesMutable();
  ::mlir::OpOperand &getStridesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value limit_indices, ::mlir::Value strides);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value start_indices, ::mlir::Value limit_indices, ::mlir::Value strides);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RealDynamicSliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RealOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RealOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RealOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RealOpV1GenericAdaptorBase(RealOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class RealOpV1GenericAdaptor : public detail::RealOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RealOpV1GenericAdaptorBase;
public:
  RealOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RealOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RealOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RealOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RealOpV1>>>
  RealOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RealOpV1Adaptor : public RealOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RealOpV1GenericAdaptor::RealOpV1GenericAdaptor;
  RealOpV1Adaptor(RealOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RealOpV1 : public ::mlir::Op<RealOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RealOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RealOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.real_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RealOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RecvOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RecvOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RecvOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RecvOpV1GenericAdaptorBase(RecvOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr();
  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr();
  ::mlir::Attribute getIsHostTransfer();
};
} // namespace detail
template <typename RangeT>
class RecvOpV1GenericAdaptor : public detail::RecvOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RecvOpV1GenericAdaptorBase;
public:
  RecvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RecvOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RecvOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RecvOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RecvOpV1>>>
  RecvOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getToken() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RecvOpV1Adaptor : public RecvOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RecvOpV1GenericAdaptor::RecvOpV1GenericAdaptor;
  RecvOpV1Adaptor(RecvOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RecvOpV1 : public ::mlir::Op<RecvOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RecvOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RecvOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("channel_type"), ::llvm::StringRef("is_host_transfer")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getChannelTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getChannelTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIsHostTransferAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIsHostTransferAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.recv_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getToken();
  ::mlir::OpOperand &getTokenMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr();
  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr();
  ::mlir::Attribute getIsHostTransfer();
  void setChannelIdAttr(::mlir::Attribute attr);
  void setChannelTypeAttr(::mlir::Attribute attr);
  void setIsHostTransferAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RecvOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReduceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReduceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReduceOpV1GenericAdaptorBase(ReduceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimensionsAttr();
  ::mlir::Attribute getDimensions();
  ::mlir::Region &getBody();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class ReduceOpV1GenericAdaptor : public detail::ReduceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReduceOpV1GenericAdaptorBase;
public:
  ReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReduceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReduceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReduceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReduceOpV1>>>
  ReduceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getInitValues() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReduceOpV1Adaptor : public ReduceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReduceOpV1GenericAdaptor::ReduceOpV1GenericAdaptor;
  ReduceOpV1Adaptor(ReduceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReduceOpV1 : public ::mlir::Op<ReduceOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReduceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::Operation::operand_range getInitValues();
  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::MutableOperandRange getInitValuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Region &getBody();
  ::mlir::Attribute getDimensionsAttr();
  ::mlir::Attribute getDimensions();
  void setDimensionsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::ValueRange init_values, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReducePrecisionOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReducePrecisionOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReducePrecisionOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReducePrecisionOpV1GenericAdaptorBase(ReducePrecisionOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getExponentBitsAttr();
  ::mlir::Attribute getExponentBits();
  ::mlir::Attribute getMantissaBitsAttr();
  ::mlir::Attribute getMantissaBits();
};
} // namespace detail
template <typename RangeT>
class ReducePrecisionOpV1GenericAdaptor : public detail::ReducePrecisionOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReducePrecisionOpV1GenericAdaptorBase;
public:
  ReducePrecisionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReducePrecisionOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReducePrecisionOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReducePrecisionOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReducePrecisionOpV1>>>
  ReducePrecisionOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReducePrecisionOpV1Adaptor : public ReducePrecisionOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReducePrecisionOpV1GenericAdaptor::ReducePrecisionOpV1GenericAdaptor;
  ReducePrecisionOpV1Adaptor(ReducePrecisionOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReducePrecisionOpV1 : public ::mlir::Op<ReducePrecisionOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReducePrecisionOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReducePrecisionOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("exponent_bits"), ::llvm::StringRef("mantissa_bits")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getExponentBitsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getExponentBitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getMantissaBitsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getMantissaBitsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_precision_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getOutput();
  ::mlir::Attribute getExponentBitsAttr();
  ::mlir::Attribute getExponentBits();
  ::mlir::Attribute getMantissaBitsAttr();
  ::mlir::Attribute getMantissaBits();
  void setExponentBitsAttr(::mlir::Attribute attr);
  void setMantissaBitsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value operand, ::mlir::Attribute exponent_bits, ::mlir::Attribute mantissa_bits);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute exponent_bits, ::mlir::Attribute mantissa_bits);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReducePrecisionOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceScatterOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReduceScatterOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReduceScatterOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReduceScatterOpV1GenericAdaptorBase(ReduceScatterOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getScatterDimensionAttr();
  ::mlir::Attribute getScatterDimension();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr();
  ::mlir::Attribute getUseGlobalDeviceIds();
  ::mlir::Region &getComputation();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class ReduceScatterOpV1GenericAdaptor : public detail::ReduceScatterOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReduceScatterOpV1GenericAdaptorBase;
public:
  ReduceScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReduceScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReduceScatterOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReduceScatterOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReduceScatterOpV1>>>
  ReduceScatterOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReduceScatterOpV1Adaptor : public ReduceScatterOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReduceScatterOpV1GenericAdaptor::ReduceScatterOpV1GenericAdaptor;
  ReduceScatterOpV1Adaptor(ReduceScatterOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReduceScatterOpV1 : public ::mlir::Op<ReduceScatterOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceScatterOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReduceScatterOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("scatter_dimension"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getScatterDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getScatterDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_scatter_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Region &getComputation();
  ::mlir::Attribute getScatterDimensionAttr();
  ::mlir::Attribute getScatterDimension();
  ::mlir::Attribute getReplicaGroupsAttr();
  ::mlir::Attribute getReplicaGroups();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getUseGlobalDeviceIdsAttr();
  ::mlir::Attribute getUseGlobalDeviceIds();
  void setScatterDimensionAttr(::mlir::Attribute attr);
  void setReplicaGroupsAttr(::mlir::Attribute attr);
  void setChannelIdAttr(::mlir::Attribute attr);
  void setUseGlobalDeviceIdsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute scatter_dimension, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute scatter_dimension, ::mlir::Attribute replica_groups, ::mlir::Attribute channel_id, ::mlir::Attribute use_global_device_ids);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReduceWindowOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReduceWindowOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReduceWindowOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReduceWindowOpV1GenericAdaptorBase(ReduceWindowOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getWindowDimensionsAttr();
  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getBaseDilationsAttr();
  ::mlir::Attribute getBaseDilations();
  ::mlir::Attribute getWindowDilationsAttr();
  ::mlir::Attribute getWindowDilations();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  ::mlir::Region &getBody();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class ReduceWindowOpV1GenericAdaptor : public detail::ReduceWindowOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReduceWindowOpV1GenericAdaptorBase;
public:
  ReduceWindowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReduceWindowOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReduceWindowOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReduceWindowOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReduceWindowOpV1>>>
  ReduceWindowOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getInitValues() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReduceWindowOpV1Adaptor : public ReduceWindowOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReduceWindowOpV1GenericAdaptor::ReduceWindowOpV1GenericAdaptor;
  ReduceWindowOpV1Adaptor(ReduceWindowOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReduceWindowOpV1 : public ::mlir::Op<ReduceWindowOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReduceWindowOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReduceWindowOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("base_dilations"), ::llvm::StringRef("padding"), ::llvm::StringRef("window_dilations"), ::llvm::StringRef("window_dimensions"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBaseDilationsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBaseDilationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getWindowDilationsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getWindowDilationsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getWindowDimensionsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getWindowDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reduce_window_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::Operation::operand_range getInitValues();
  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::MutableOperandRange getInitValuesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Region &getBody();
  ::mlir::Attribute getWindowDimensionsAttr();
  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getBaseDilationsAttr();
  ::mlir::Attribute getBaseDilations();
  ::mlir::Attribute getWindowDilationsAttr();
  ::mlir::Attribute getWindowDilations();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  void setWindowDimensionsAttr(::mlir::Attribute attr);
  void setWindowStridesAttr(::mlir::Attribute attr);
  void setBaseDilationsAttr(::mlir::Attribute attr);
  void setWindowDilationsAttr(::mlir::Attribute attr);
  void setPaddingAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::ValueRange init_values, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute base_dilations, ::mlir::Attribute window_dilations, ::mlir::Attribute padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 5 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReduceWindowOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RemOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RemOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RemOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RemOpV1GenericAdaptorBase(RemOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class RemOpV1GenericAdaptor : public detail::RemOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RemOpV1GenericAdaptorBase;
public:
  RemOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RemOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RemOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RemOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RemOpV1>>>
  RemOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RemOpV1Adaptor : public RemOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RemOpV1GenericAdaptor::RemOpV1GenericAdaptor;
  RemOpV1Adaptor(RemOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RemOpV1 : public ::mlir::Op<RemOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RemOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RemOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.remainder_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RemOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReplicaIdOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReplicaIdOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReplicaIdOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReplicaIdOpV1GenericAdaptorBase(ReplicaIdOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ReplicaIdOpV1GenericAdaptor : public detail::ReplicaIdOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReplicaIdOpV1GenericAdaptorBase;
public:
  ReplicaIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReplicaIdOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReplicaIdOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReplicaIdOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReplicaIdOpV1>>>
  ReplicaIdOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReplicaIdOpV1Adaptor : public ReplicaIdOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReplicaIdOpV1GenericAdaptor::ReplicaIdOpV1GenericAdaptor;
  ReplicaIdOpV1Adaptor(ReplicaIdOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReplicaIdOpV1 : public ::mlir::Op<ReplicaIdOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReplicaIdOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReplicaIdOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.replica_id_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReplicaIdOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReshapeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReshapeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReshapeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReshapeOpV1GenericAdaptorBase(ReshapeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ReshapeOpV1GenericAdaptor : public detail::ReshapeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReshapeOpV1GenericAdaptorBase;
public:
  ReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReshapeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReshapeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReshapeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReshapeOpV1>>>
  ReshapeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReshapeOpV1Adaptor : public ReshapeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReshapeOpV1GenericAdaptor::ReshapeOpV1GenericAdaptor;
  ReshapeOpV1Adaptor(ReshapeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReshapeOpV1 : public ::mlir::Op<ReshapeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReshapeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReshapeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reshape_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReshapeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReturnOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReturnOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReturnOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReturnOpV1GenericAdaptorBase(ReturnOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ReturnOpV1GenericAdaptor : public detail::ReturnOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReturnOpV1GenericAdaptorBase;
public:
  ReturnOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReturnOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReturnOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReturnOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReturnOpV1>>>
  ReturnOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getResults() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReturnOpV1Adaptor : public ReturnOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReturnOpV1GenericAdaptor::ReturnOpV1GenericAdaptor;
  ReturnOpV1Adaptor(ReturnOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReturnOpV1 : public ::mlir::Op<ReturnOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpTrait::IsTerminator> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReturnOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReturnOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.return_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getResults();
  ::mlir::MutableOperandRange getResultsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange results);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReturnOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ReverseOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReverseOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReverseOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReverseOpV1GenericAdaptorBase(ReverseOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimensionsAttr();
  ::mlir::Attribute getDimensions();
};
} // namespace detail
template <typename RangeT>
class ReverseOpV1GenericAdaptor : public detail::ReverseOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReverseOpV1GenericAdaptorBase;
public:
  ReverseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReverseOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReverseOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReverseOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ReverseOpV1>>>
  ReverseOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReverseOpV1Adaptor : public ReverseOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ReverseOpV1GenericAdaptor::ReverseOpV1GenericAdaptor;
  ReverseOpV1Adaptor(ReverseOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReverseOpV1 : public ::mlir::Op<ReverseOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReverseOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ReverseOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimensions")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.reverse_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getDimensionsAttr();
  ::mlir::Attribute getDimensions();
  void setDimensionsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute dimensions);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ReverseOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RngBitGeneratorOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RngBitGeneratorOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RngBitGeneratorOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RngBitGeneratorOpV1GenericAdaptorBase(RngBitGeneratorOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getRngAlgorithmAttr();
  ::mlir::Attribute getRngAlgorithm();
};
} // namespace detail
template <typename RangeT>
class RngBitGeneratorOpV1GenericAdaptor : public detail::RngBitGeneratorOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RngBitGeneratorOpV1GenericAdaptorBase;
public:
  RngBitGeneratorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RngBitGeneratorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RngBitGeneratorOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RngBitGeneratorOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RngBitGeneratorOpV1>>>
  RngBitGeneratorOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getInitialState() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RngBitGeneratorOpV1Adaptor : public RngBitGeneratorOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RngBitGeneratorOpV1GenericAdaptor::RngBitGeneratorOpV1GenericAdaptor;
  RngBitGeneratorOpV1Adaptor(RngBitGeneratorOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RngBitGeneratorOpV1 : public ::mlir::Op<RngBitGeneratorOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::NResults<2>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait, ::mlir::OpAsmOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RngBitGeneratorOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RngBitGeneratorOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("rng_algorithm")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getRngAlgorithmAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getRngAlgorithmAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  void getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn);
  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.rng_bit_generator_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getInitialState();
  ::mlir::OpOperand &getInitialStateMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getOutputState();
  ::mlir::Value getOutput();
  ::mlir::Attribute getRngAlgorithmAttr();
  ::mlir::Attribute getRngAlgorithm();
  void setRngAlgorithmAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output_state, ::mlir::Type output, ::mlir::Attribute rng_algorithm, ::mlir::Value initial_state);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute rng_algorithm, ::mlir::Value initial_state);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RngBitGeneratorOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RngOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RngOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RngOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RngOpV1GenericAdaptorBase(RngOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getRngDistributionAttr();
  ::mlir::Attribute getRngDistribution();
};
} // namespace detail
template <typename RangeT>
class RngOpV1GenericAdaptor : public detail::RngOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RngOpV1GenericAdaptorBase;
public:
  RngOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RngOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RngOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RngOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RngOpV1>>>
  RngOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getA() {
    return (*getODSOperands(0).begin());
  }

  ValueT getB() {
    return (*getODSOperands(1).begin());
  }

  ValueT getShape() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RngOpV1Adaptor : public RngOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RngOpV1GenericAdaptor::RngOpV1GenericAdaptor;
  RngOpV1Adaptor(RngOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RngOpV1 : public ::mlir::Op<RngOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RngOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RngOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("rng_distribution")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getRngDistributionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getRngDistributionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.rng_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getA();
  ::mlir::Value getB();
  ::mlir::Value getShape();
  ::mlir::OpOperand &getAMutable();
  ::mlir::OpOperand &getBMutable();
  ::mlir::OpOperand &getShapeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getRngDistributionAttr();
  ::mlir::Attribute getRngDistribution();
  void setRngDistributionAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Value b, ::mlir::Value shape, ::mlir::Attribute rng_distribution);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Value shape, ::mlir::Attribute rng_distribution);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RngOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RoundNearestEvenOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RoundNearestEvenOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RoundNearestEvenOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RoundNearestEvenOpV1GenericAdaptorBase(RoundNearestEvenOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class RoundNearestEvenOpV1GenericAdaptor : public detail::RoundNearestEvenOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RoundNearestEvenOpV1GenericAdaptorBase;
public:
  RoundNearestEvenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RoundNearestEvenOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RoundNearestEvenOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RoundNearestEvenOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RoundNearestEvenOpV1>>>
  RoundNearestEvenOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RoundNearestEvenOpV1Adaptor : public RoundNearestEvenOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RoundNearestEvenOpV1GenericAdaptor::RoundNearestEvenOpV1GenericAdaptor;
  RoundNearestEvenOpV1Adaptor(RoundNearestEvenOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RoundNearestEvenOpV1 : public ::mlir::Op<RoundNearestEvenOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RoundNearestEvenOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RoundNearestEvenOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.round_nearest_even_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RoundNearestEvenOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RoundOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RoundOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RoundOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RoundOpV1GenericAdaptorBase(RoundOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class RoundOpV1GenericAdaptor : public detail::RoundOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RoundOpV1GenericAdaptorBase;
public:
  RoundOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RoundOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RoundOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RoundOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RoundOpV1>>>
  RoundOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RoundOpV1Adaptor : public RoundOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RoundOpV1GenericAdaptor::RoundOpV1GenericAdaptor;
  RoundOpV1Adaptor(RoundOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RoundOpV1 : public ::mlir::Op<RoundOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RoundOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RoundOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.round_nearest_afz_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RoundOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::RsqrtOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RsqrtOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  RsqrtOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  RsqrtOpV1GenericAdaptorBase(RsqrtOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class RsqrtOpV1GenericAdaptor : public detail::RsqrtOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RsqrtOpV1GenericAdaptorBase;
public:
  RsqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RsqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RsqrtOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = RsqrtOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, RsqrtOpV1>>>
  RsqrtOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RsqrtOpV1Adaptor : public RsqrtOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using RsqrtOpV1GenericAdaptor::RsqrtOpV1GenericAdaptor;
  RsqrtOpV1Adaptor(RsqrtOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RsqrtOpV1 : public ::mlir::Op<RsqrtOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RsqrtOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = RsqrtOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.rsqrt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::RsqrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ScatterOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ScatterOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ScatterOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ScatterOpV1GenericAdaptorBase(ScatterOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getUpdateWindowDimsAttr();
  ::mlir::Attribute getUpdateWindowDims();
  ::mlir::Attribute getInsertedWindowDimsAttr();
  ::mlir::Attribute getInsertedWindowDims();
  ::mlir::Attribute getScatterDimsToOperandDimsAttr();
  ::mlir::Attribute getScatterDimsToOperandDims();
  ::mlir::Attribute getIndexVectorDimAttr();
  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr();
  ::mlir::Attribute getIndicesAreSorted();
  ::mlir::Attribute getUniqueIndicesAttr();
  ::mlir::Attribute getUniqueIndices();
  ::mlir::Region &getUpdateComputation();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class ScatterOpV1GenericAdaptor : public detail::ScatterOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ScatterOpV1GenericAdaptorBase;
public:
  ScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ScatterOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ScatterOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ScatterOpV1>>>
  ScatterOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  ValueT getScatterIndices() {
    return (*getODSOperands(1).begin());
  }

  RangeT getUpdates() {
    return getODSOperands(2);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ScatterOpV1Adaptor : public ScatterOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ScatterOpV1GenericAdaptor::ScatterOpV1GenericAdaptor;
  ScatterOpV1Adaptor(ScatterOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ScatterOpV1 : public ::mlir::Op<ScatterOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ScatterOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ScatterOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("index_vector_dim"), ::llvm::StringRef("indices_are_sorted"), ::llvm::StringRef("inserted_window_dims"), ::llvm::StringRef("scatter_dims_to_operand_dims"), ::llvm::StringRef("unique_indices"), ::llvm::StringRef("update_window_dims")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getIndexVectorDimAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getIndexVectorDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIndicesAreSortedAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIndicesAreSortedAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInsertedWindowDimsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInsertedWindowDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getScatterDimsToOperandDimsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getScatterDimsToOperandDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getUniqueIndicesAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getUniqueIndicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getUpdateWindowDimsAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getUpdateWindowDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.scatter_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::Value getScatterIndices();
  ::mlir::Operation::operand_range getUpdates();
  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::OpOperand &getScatterIndicesMutable();
  ::mlir::MutableOperandRange getUpdatesMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Region &getUpdateComputation();
  ::mlir::Attribute getUpdateWindowDimsAttr();
  ::mlir::Attribute getUpdateWindowDims();
  ::mlir::Attribute getInsertedWindowDimsAttr();
  ::mlir::Attribute getInsertedWindowDims();
  ::mlir::Attribute getScatterDimsToOperandDimsAttr();
  ::mlir::Attribute getScatterDimsToOperandDims();
  ::mlir::Attribute getIndexVectorDimAttr();
  ::mlir::Attribute getIndexVectorDim();
  ::mlir::Attribute getIndicesAreSortedAttr();
  ::mlir::Attribute getIndicesAreSorted();
  ::mlir::Attribute getUniqueIndicesAttr();
  ::mlir::Attribute getUniqueIndices();
  void setUpdateWindowDimsAttr(::mlir::Attribute attr);
  void setInsertedWindowDimsAttr(::mlir::Attribute attr);
  void setScatterDimsToOperandDimsAttr(::mlir::Attribute attr);
  void setIndexVectorDimAttr(::mlir::Attribute attr);
  void setIndicesAreSortedAttr(::mlir::Attribute attr);
  void setUniqueIndicesAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Value scatter_indices, ::mlir::ValueRange updates, ::mlir::Attribute update_window_dims, ::mlir::Attribute inserted_window_dims, ::mlir::Attribute scatter_dims_to_operand_dims, ::mlir::Attribute index_vector_dim, ::mlir::Attribute indices_are_sorted, ::mlir::Attribute unique_indices);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 6 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SelectAndScatterOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SelectAndScatterOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SelectAndScatterOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SelectAndScatterOpV1GenericAdaptorBase(SelectAndScatterOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getWindowDimensionsAttr();
  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  ::mlir::Region &getSelect();
  ::mlir::Region &getScatter();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class SelectAndScatterOpV1GenericAdaptor : public detail::SelectAndScatterOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SelectAndScatterOpV1GenericAdaptorBase;
public:
  SelectAndScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SelectAndScatterOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SelectAndScatterOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SelectAndScatterOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SelectAndScatterOpV1>>>
  SelectAndScatterOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getSource() {
    return (*getODSOperands(1).begin());
  }

  ValueT getInitValue() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SelectAndScatterOpV1Adaptor : public SelectAndScatterOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SelectAndScatterOpV1GenericAdaptor::SelectAndScatterOpV1GenericAdaptor;
  SelectAndScatterOpV1Adaptor(SelectAndScatterOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SelectAndScatterOpV1 : public ::mlir::Op<SelectAndScatterOpV1, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SelectAndScatterOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SelectAndScatterOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("padding"), ::llvm::StringRef("window_dimensions"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getWindowDimensionsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getWindowDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.select_and_scatter_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getSource();
  ::mlir::Value getInitValue();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getSourceMutable();
  ::mlir::OpOperand &getInitValueMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Region &getSelect();
  ::mlir::Region &getScatter();
  ::mlir::Attribute getWindowDimensionsAttr();
  ::mlir::Attribute getWindowDimensions();
  ::mlir::Attribute getWindowStridesAttr();
  ::mlir::Attribute getWindowStrides();
  ::mlir::Attribute getPaddingAttr();
  ::mlir::Attribute getPadding();
  void setWindowDimensionsAttr(::mlir::Attribute attr);
  void setWindowStridesAttr(::mlir::Attribute attr);
  void setPaddingAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value source, ::mlir::Value init_value, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute padding);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value source, ::mlir::Value init_value, ::mlir::Attribute window_dimensions, ::mlir::Attribute window_strides, ::mlir::Attribute padding);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SelectAndScatterOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SelectOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SelectOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SelectOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SelectOpV1GenericAdaptorBase(SelectOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class SelectOpV1GenericAdaptor : public detail::SelectOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SelectOpV1GenericAdaptorBase;
public:
  SelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SelectOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SelectOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SelectOpV1>>>
  SelectOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getPred() {
    return (*getODSOperands(0).begin());
  }

  ValueT getOnTrue() {
    return (*getODSOperands(1).begin());
  }

  ValueT getOnFalse() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SelectOpV1Adaptor : public SelectOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SelectOpV1GenericAdaptor::SelectOpV1GenericAdaptor;
  SelectOpV1Adaptor(SelectOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SelectOpV1 : public ::mlir::Op<SelectOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SelectOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SelectOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.select_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getPred();
  ::mlir::Value getOnTrue();
  ::mlir::Value getOnFalse();
  ::mlir::OpOperand &getPredMutable();
  ::mlir::OpOperand &getOnTrueMutable();
  ::mlir::OpOperand &getOnFalseMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pred, ::mlir::Value on_true, ::mlir::Value on_false);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pred, ::mlir::Value on_true, ::mlir::Value on_false);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SelectOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SendOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SendOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SendOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SendOpV1GenericAdaptorBase(SendOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr();
  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr();
  ::mlir::Attribute getIsHostTransfer();
};
} // namespace detail
template <typename RangeT>
class SendOpV1GenericAdaptor : public detail::SendOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SendOpV1GenericAdaptorBase;
public:
  SendOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SendOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SendOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SendOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SendOpV1>>>
  SendOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  ValueT getToken() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SendOpV1Adaptor : public SendOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SendOpV1GenericAdaptor::SendOpV1GenericAdaptor;
  SendOpV1Adaptor(SendOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SendOpV1 : public ::mlir::Op<SendOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::AtLeastNOperands<1>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SendOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SendOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id"), ::llvm::StringRef("channel_type"), ::llvm::StringRef("is_host_transfer")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getChannelTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getChannelTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getIsHostTransferAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getIsHostTransferAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.send_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::Value getToken();
  ::mlir::MutableOperandRange getInputsMutable();
  ::mlir::OpOperand &getTokenMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getChannelIdAttr();
  ::mlir::Attribute getChannelId();
  ::mlir::Attribute getChannelTypeAttr();
  ::mlir::Attribute getChannelType();
  ::mlir::Attribute getIsHostTransferAttr();
  ::mlir::Attribute getIsHostTransfer();
  void setChannelIdAttr(::mlir::Attribute attr);
  void setChannelTypeAttr(::mlir::Attribute attr);
  void setIsHostTransferAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::Value token, ::mlir::Attribute channel_id, ::mlir::Attribute channel_type, ::mlir::Attribute is_host_transfer);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SendOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SetDimensionSizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SetDimensionSizeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SetDimensionSizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SetDimensionSizeOpV1GenericAdaptorBase(SetDimensionSizeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
};
} // namespace detail
template <typename RangeT>
class SetDimensionSizeOpV1GenericAdaptor : public detail::SetDimensionSizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SetDimensionSizeOpV1GenericAdaptorBase;
public:
  SetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SetDimensionSizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SetDimensionSizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SetDimensionSizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SetDimensionSizeOpV1>>>
  SetDimensionSizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getSize() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SetDimensionSizeOpV1Adaptor : public SetDimensionSizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SetDimensionSizeOpV1GenericAdaptor::SetDimensionSizeOpV1GenericAdaptor;
  SetDimensionSizeOpV1Adaptor(SetDimensionSizeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SetDimensionSizeOpV1 : public ::mlir::Op<SetDimensionSizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SetDimensionSizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SetDimensionSizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.set_dimension_size_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getSize();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getSizeMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
  void setDimensionAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value size, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value size, ::mlir::Attribute dimension);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SetDimensionSizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftLeftOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ShiftLeftOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ShiftLeftOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ShiftLeftOpV1GenericAdaptorBase(ShiftLeftOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ShiftLeftOpV1GenericAdaptor : public detail::ShiftLeftOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ShiftLeftOpV1GenericAdaptorBase;
public:
  ShiftLeftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ShiftLeftOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ShiftLeftOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ShiftLeftOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ShiftLeftOpV1>>>
  ShiftLeftOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ShiftLeftOpV1Adaptor : public ShiftLeftOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ShiftLeftOpV1GenericAdaptor::ShiftLeftOpV1GenericAdaptor;
  ShiftLeftOpV1Adaptor(ShiftLeftOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ShiftLeftOpV1 : public ::mlir::Op<ShiftLeftOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShiftLeftOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ShiftLeftOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.shift_left_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftLeftOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftRightArithmeticOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ShiftRightArithmeticOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ShiftRightArithmeticOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ShiftRightArithmeticOpV1GenericAdaptorBase(ShiftRightArithmeticOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ShiftRightArithmeticOpV1GenericAdaptor : public detail::ShiftRightArithmeticOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ShiftRightArithmeticOpV1GenericAdaptorBase;
public:
  ShiftRightArithmeticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ShiftRightArithmeticOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ShiftRightArithmeticOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ShiftRightArithmeticOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ShiftRightArithmeticOpV1>>>
  ShiftRightArithmeticOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ShiftRightArithmeticOpV1Adaptor : public ShiftRightArithmeticOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ShiftRightArithmeticOpV1GenericAdaptor::ShiftRightArithmeticOpV1GenericAdaptor;
  ShiftRightArithmeticOpV1Adaptor(ShiftRightArithmeticOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ShiftRightArithmeticOpV1 : public ::mlir::Op<ShiftRightArithmeticOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShiftRightArithmeticOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ShiftRightArithmeticOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.shift_right_arithmetic_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftRightArithmeticOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::ShiftRightLogicalOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ShiftRightLogicalOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ShiftRightLogicalOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ShiftRightLogicalOpV1GenericAdaptorBase(ShiftRightLogicalOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class ShiftRightLogicalOpV1GenericAdaptor : public detail::ShiftRightLogicalOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ShiftRightLogicalOpV1GenericAdaptorBase;
public:
  ShiftRightLogicalOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ShiftRightLogicalOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ShiftRightLogicalOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ShiftRightLogicalOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, ShiftRightLogicalOpV1>>>
  ShiftRightLogicalOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ShiftRightLogicalOpV1Adaptor : public ShiftRightLogicalOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using ShiftRightLogicalOpV1GenericAdaptor::ShiftRightLogicalOpV1GenericAdaptor;
  ShiftRightLogicalOpV1Adaptor(ShiftRightLogicalOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ShiftRightLogicalOpV1 : public ::mlir::Op<ShiftRightLogicalOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ShiftRightLogicalOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = ShiftRightLogicalOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.shift_right_logical_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::ShiftRightLogicalOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SignOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SignOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SignOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SignOpV1GenericAdaptorBase(SignOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class SignOpV1GenericAdaptor : public detail::SignOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SignOpV1GenericAdaptorBase;
public:
  SignOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SignOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SignOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SignOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SignOpV1>>>
  SignOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SignOpV1Adaptor : public SignOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SignOpV1GenericAdaptor::SignOpV1GenericAdaptor;
  SignOpV1Adaptor(SignOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SignOpV1 : public ::mlir::Op<SignOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SignOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SignOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sign_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SignOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SineOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SineOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SineOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SineOpV1GenericAdaptorBase(SineOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class SineOpV1GenericAdaptor : public detail::SineOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SineOpV1GenericAdaptorBase;
public:
  SineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SineOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SineOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SineOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SineOpV1>>>
  SineOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SineOpV1Adaptor : public SineOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SineOpV1GenericAdaptor::SineOpV1GenericAdaptor;
  SineOpV1Adaptor(SineOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SineOpV1 : public ::mlir::Op<SineOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SineOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SineOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sine_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SineOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SliceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SliceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SliceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SliceOpV1GenericAdaptorBase(SliceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getStartIndicesAttr();
  ::mlir::Attribute getStartIndices();
  ::mlir::Attribute getLimitIndicesAttr();
  ::mlir::Attribute getLimitIndices();
  ::mlir::Attribute getStridesAttr();
  ::mlir::Attribute getStrides();
};
} // namespace detail
template <typename RangeT>
class SliceOpV1GenericAdaptor : public detail::SliceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SliceOpV1GenericAdaptorBase;
public:
  SliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SliceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SliceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SliceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SliceOpV1>>>
  SliceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SliceOpV1Adaptor : public SliceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SliceOpV1GenericAdaptor::SliceOpV1GenericAdaptor;
  SliceOpV1Adaptor(SliceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SliceOpV1 : public ::mlir::Op<SliceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SliceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SliceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("limit_indices"), ::llvm::StringRef("start_indices"), ::llvm::StringRef("strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLimitIndicesAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLimitIndicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getStartIndicesAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getStartIndicesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getStridesAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.slice_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getStartIndicesAttr();
  ::mlir::Attribute getStartIndices();
  ::mlir::Attribute getLimitIndicesAttr();
  ::mlir::Attribute getLimitIndices();
  ::mlir::Attribute getStridesAttr();
  ::mlir::Attribute getStrides();
  void setStartIndicesAttr(::mlir::Attribute attr);
  void setLimitIndicesAttr(::mlir::Attribute attr);
  void setStridesAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute start_indices, ::mlir::Attribute limit_indices, ::mlir::Attribute strides);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute start_indices, ::mlir::Attribute limit_indices, ::mlir::Attribute strides);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 3 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SliceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SortOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SortOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SortOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SortOpV1GenericAdaptorBase(SortOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
  ::mlir::Attribute getIsStableAttr();
  ::mlir::Attribute getIsStable();
  ::mlir::Region &getComparator();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class SortOpV1GenericAdaptor : public detail::SortOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SortOpV1GenericAdaptorBase;
public:
  SortOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SortOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SortOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SortOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SortOpV1>>>
  SortOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getInputs() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SortOpV1Adaptor : public SortOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SortOpV1GenericAdaptor::SortOpV1GenericAdaptor;
  SortOpV1Adaptor(SortOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SortOpV1 : public ::mlir::Op<SortOpV1, ::mlir::OpTrait::OneRegion, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SortOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SortOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("dimension"), ::llvm::StringRef("is_stable")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getDimensionAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getIsStableAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getIsStableAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sort_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getInputs();
  ::mlir::MutableOperandRange getInputsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Region &getComparator();
  ::mlir::Attribute getDimensionAttr();
  ::mlir::Attribute getDimension();
  ::mlir::Attribute getIsStableAttr();
  ::mlir::Attribute getIsStable();
  void setDimensionAttr(::mlir::Attribute attr);
  void setIsStableAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange inputs, ::mlir::Attribute dimension, ::mlir::Attribute is_stable);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SortOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SqrtOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SqrtOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SqrtOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SqrtOpV1GenericAdaptorBase(SqrtOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class SqrtOpV1GenericAdaptor : public detail::SqrtOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SqrtOpV1GenericAdaptorBase;
public:
  SqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SqrtOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SqrtOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SqrtOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SqrtOpV1>>>
  SqrtOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SqrtOpV1Adaptor : public SqrtOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SqrtOpV1GenericAdaptor::SqrtOpV1GenericAdaptor;
  SqrtOpV1Adaptor(SqrtOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SqrtOpV1 : public ::mlir::Op<SqrtOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SqrtOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SqrtOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.sqrt_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SqrtOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::SubtractOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class SubtractOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  SubtractOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  SubtractOpV1GenericAdaptorBase(SubtractOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class SubtractOpV1GenericAdaptor : public detail::SubtractOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::SubtractOpV1GenericAdaptorBase;
public:
  SubtractOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  SubtractOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : SubtractOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = SubtractOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, SubtractOpV1>>>
  SubtractOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class SubtractOpV1Adaptor : public SubtractOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using SubtractOpV1GenericAdaptor::SubtractOpV1GenericAdaptor;
  SubtractOpV1Adaptor(SubtractOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class SubtractOpV1 : public ::mlir::Op<SubtractOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = SubtractOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = SubtractOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.subtract_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::SubtractOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TanhOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TanhOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TanhOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  TanhOpV1GenericAdaptorBase(TanhOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class TanhOpV1GenericAdaptor : public detail::TanhOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TanhOpV1GenericAdaptorBase;
public:
  TanhOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TanhOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TanhOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TanhOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TanhOpV1>>>
  TanhOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TanhOpV1Adaptor : public TanhOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TanhOpV1GenericAdaptor::TanhOpV1GenericAdaptor;
  TanhOpV1Adaptor(TanhOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class TanhOpV1 : public ::mlir::Op<TanhOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TanhOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TanhOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.tanh_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TanhOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TorchIndexSelectOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TorchIndexSelectOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TorchIndexSelectOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  TorchIndexSelectOpV1GenericAdaptorBase(TorchIndexSelectOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getDimAttr();
  ::mlir::Attribute getDim();
  ::mlir::Attribute getBatchDimsAttr();
  ::mlir::Attribute getBatchDims();
};
} // namespace detail
template <typename RangeT>
class TorchIndexSelectOpV1GenericAdaptor : public detail::TorchIndexSelectOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TorchIndexSelectOpV1GenericAdaptorBase;
public:
  TorchIndexSelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TorchIndexSelectOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TorchIndexSelectOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TorchIndexSelectOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TorchIndexSelectOpV1>>>
  TorchIndexSelectOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getIndex() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TorchIndexSelectOpV1Adaptor : public TorchIndexSelectOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TorchIndexSelectOpV1GenericAdaptor::TorchIndexSelectOpV1GenericAdaptor;
  TorchIndexSelectOpV1Adaptor(TorchIndexSelectOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class TorchIndexSelectOpV1 : public ::mlir::Op<TorchIndexSelectOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TorchIndexSelectOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TorchIndexSelectOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_dims"), ::llvm::StringRef("dim")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchDimsAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchDimsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getDimAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getDimAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.torch_index_select_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::Value getIndex();
  ::mlir::OpOperand &getOperandMutable();
  ::mlir::OpOperand &getIndexMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getDimAttr();
  ::mlir::Attribute getDim();
  ::mlir::Attribute getBatchDimsAttr();
  ::mlir::Attribute getBatchDims();
  void setDimAttr(::mlir::Attribute attr);
  void setBatchDimsAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value index, ::mlir::Attribute dim, ::mlir::Attribute batch_dims);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value index, ::mlir::Attribute dim, ::mlir::Attribute batch_dims);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TorchIndexSelectOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TraceOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TraceOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TraceOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  TraceOpV1GenericAdaptorBase(TraceOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getTagAttr();
  ::mlir::Attribute getTag();
};
} // namespace detail
template <typename RangeT>
class TraceOpV1GenericAdaptor : public detail::TraceOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TraceOpV1GenericAdaptorBase;
public:
  TraceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TraceOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TraceOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TraceOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TraceOpV1>>>
  TraceOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TraceOpV1Adaptor : public TraceOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TraceOpV1GenericAdaptor::TraceOpV1GenericAdaptor;
  TraceOpV1Adaptor(TraceOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class TraceOpV1 : public ::mlir::Op<TraceOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TraceOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TraceOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("tag")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getTagAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getTagAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.trace_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Attribute getTagAttr();
  ::mlir::Attribute getTag();
  void setTagAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand, ::mlir::Attribute tag);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute tag);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TraceOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TransposeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TransposeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TransposeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  TransposeOpV1GenericAdaptorBase(TransposeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getPermutationAttr();
  ::mlir::Attribute getPermutation();
};
} // namespace detail
template <typename RangeT>
class TransposeOpV1GenericAdaptor : public detail::TransposeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TransposeOpV1GenericAdaptorBase;
public:
  TransposeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TransposeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TransposeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TransposeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TransposeOpV1>>>
  TransposeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TransposeOpV1Adaptor : public TransposeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TransposeOpV1GenericAdaptor::TransposeOpV1GenericAdaptor;
  TransposeOpV1Adaptor(TransposeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class TransposeOpV1 : public ::mlir::Op<TransposeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TransposeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TransposeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("permutation")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getPermutationAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getPermutationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.transpose_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getPermutationAttr();
  ::mlir::Attribute getPermutation();
  void setPermutationAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute permutation);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute permutation);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TransposeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TriangularSolveOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TriangularSolveOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TriangularSolveOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  TriangularSolveOpV1GenericAdaptorBase(TriangularSolveOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getLeftSideAttr();
  ::mlir::Attribute getLeftSide();
  ::mlir::Attribute getLowerAttr();
  ::mlir::Attribute getLower();
  ::mlir::Attribute getUnitDiagonalAttr();
  ::mlir::Attribute getUnitDiagonal();
  ::mlir::Attribute getTransposeAAttr();
  ::mlir::Attribute getTransposeA();
};
} // namespace detail
template <typename RangeT>
class TriangularSolveOpV1GenericAdaptor : public detail::TriangularSolveOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TriangularSolveOpV1GenericAdaptorBase;
public:
  TriangularSolveOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TriangularSolveOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TriangularSolveOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TriangularSolveOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TriangularSolveOpV1>>>
  TriangularSolveOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getA() {
    return (*getODSOperands(0).begin());
  }

  ValueT getB() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TriangularSolveOpV1Adaptor : public TriangularSolveOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TriangularSolveOpV1GenericAdaptor::TriangularSolveOpV1GenericAdaptor;
  TriangularSolveOpV1Adaptor(TriangularSolveOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class TriangularSolveOpV1 : public ::mlir::Op<TriangularSolveOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TriangularSolveOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TriangularSolveOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("left_side"), ::llvm::StringRef("lower"), ::llvm::StringRef("transpose_a"), ::llvm::StringRef("unit_diagonal")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getLeftSideAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getLeftSideAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getLowerAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getLowerAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getTransposeAAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getTransposeAAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUnitDiagonalAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUnitDiagonalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.triangular_solve_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getA();
  ::mlir::Value getB();
  ::mlir::OpOperand &getAMutable();
  ::mlir::OpOperand &getBMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getLeftSideAttr();
  ::mlir::Attribute getLeftSide();
  ::mlir::Attribute getLowerAttr();
  ::mlir::Attribute getLower();
  ::mlir::Attribute getUnitDiagonalAttr();
  ::mlir::Attribute getUnitDiagonal();
  ::mlir::Attribute getTransposeAAttr();
  ::mlir::Attribute getTransposeA();
  void setLeftSideAttr(::mlir::Attribute attr);
  void setLowerAttr(::mlir::Attribute attr);
  void setUnitDiagonalAttr(::mlir::Attribute attr);
  void setTransposeAAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Value b, ::mlir::Attribute left_side, ::mlir::Attribute lower, ::mlir::Attribute unit_diagonal, ::mlir::Attribute transpose_a);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Attribute left_side, ::mlir::Attribute lower, ::mlir::Attribute unit_diagonal, ::mlir::Attribute transpose_a);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TriangularSolveOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::TupleOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class TupleOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  TupleOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  TupleOpV1GenericAdaptorBase(TupleOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class TupleOpV1GenericAdaptor : public detail::TupleOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::TupleOpV1GenericAdaptorBase;
public:
  TupleOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  TupleOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : TupleOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = TupleOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, TupleOpV1>>>
  TupleOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getVal() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class TupleOpV1Adaptor : public TupleOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using TupleOpV1GenericAdaptor::TupleOpV1GenericAdaptor;
  TupleOpV1Adaptor(TupleOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class TupleOpV1 : public ::mlir::Op<TupleOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = TupleOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = TupleOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.tuple_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getVal();
  ::mlir::MutableOperandRange getValMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange val);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::TupleOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UnaryEinsumOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UnaryEinsumOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  UnaryEinsumOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  UnaryEinsumOpV1GenericAdaptorBase(UnaryEinsumOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Attribute getEinsumConfigAttr();
  ::mlir::Attribute getEinsumConfig();
};
} // namespace detail
template <typename RangeT>
class UnaryEinsumOpV1GenericAdaptor : public detail::UnaryEinsumOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UnaryEinsumOpV1GenericAdaptorBase;
public:
  UnaryEinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UnaryEinsumOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UnaryEinsumOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = UnaryEinsumOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, UnaryEinsumOpV1>>>
  UnaryEinsumOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UnaryEinsumOpV1Adaptor : public UnaryEinsumOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using UnaryEinsumOpV1GenericAdaptor::UnaryEinsumOpV1GenericAdaptor;
  UnaryEinsumOpV1Adaptor(UnaryEinsumOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class UnaryEinsumOpV1 : public ::mlir::Op<UnaryEinsumOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UnaryEinsumOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = UnaryEinsumOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("einsum_config")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getEinsumConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getEinsumConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.unary_einsum_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  ::mlir::Attribute getEinsumConfigAttr();
  ::mlir::Attribute getEinsumConfig();
  void setEinsumConfigAttr(::mlir::Attribute attr);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Attribute einsum_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    return name.getAttributeNames()[index];
  }

public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::UnaryEinsumOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UniformDequantizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UniformDequantizeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  UniformDequantizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  UniformDequantizeOpV1GenericAdaptorBase(UniformDequantizeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class UniformDequantizeOpV1GenericAdaptor : public detail::UniformDequantizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UniformDequantizeOpV1GenericAdaptorBase;
public:
  UniformDequantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UniformDequantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UniformDequantizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = UniformDequantizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, UniformDequantizeOpV1>>>
  UniformDequantizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UniformDequantizeOpV1Adaptor : public UniformDequantizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using UniformDequantizeOpV1GenericAdaptor::UniformDequantizeOpV1GenericAdaptor;
  UniformDequantizeOpV1Adaptor(UniformDequantizeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class UniformDequantizeOpV1 : public ::mlir::Op<UniformDequantizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UniformDequantizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = UniformDequantizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.uniform_dequantize_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::UniformDequantizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::UniformQuantizeOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class UniformQuantizeOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  UniformQuantizeOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  UniformQuantizeOpV1GenericAdaptorBase(UniformQuantizeOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class UniformQuantizeOpV1GenericAdaptor : public detail::UniformQuantizeOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::UniformQuantizeOpV1GenericAdaptorBase;
public:
  UniformQuantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  UniformQuantizeOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : UniformQuantizeOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = UniformQuantizeOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, UniformQuantizeOpV1>>>
  UniformQuantizeOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class UniformQuantizeOpV1Adaptor : public UniformQuantizeOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using UniformQuantizeOpV1GenericAdaptor::UniformQuantizeOpV1GenericAdaptor;
  UniformQuantizeOpV1Adaptor(UniformQuantizeOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class UniformQuantizeOpV1 : public ::mlir::Op<UniformQuantizeOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = UniformQuantizeOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = UniformQuantizeOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.uniform_quantize_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getOperand();
  ::mlir::OpOperand &getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::UniformQuantizeOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::WhileOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class WhileOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  WhileOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  WhileOpV1GenericAdaptorBase(WhileOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
  ::mlir::Region &getCond();
  ::mlir::Region &getBody();
  ::mlir::RegionRange getRegions();
};
} // namespace detail
template <typename RangeT>
class WhileOpV1GenericAdaptor : public detail::WhileOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::WhileOpV1GenericAdaptorBase;
public:
  WhileOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  WhileOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : WhileOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = WhileOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, WhileOpV1>>>
  WhileOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperand() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class WhileOpV1Adaptor : public WhileOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using WhileOpV1GenericAdaptor::WhileOpV1GenericAdaptor;
  WhileOpV1Adaptor(WhileOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class WhileOpV1 : public ::mlir::Op<WhileOpV1, ::mlir::OpTrait::NRegions<2>::Impl, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = WhileOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = WhileOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.while_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Operation::operand_range getOperand();
  ::mlir::MutableOperandRange getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Operation::result_range getResults();
  ::mlir::Region &getCond();
  ::mlir::Region &getBody();
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::WhileOpV1)

namespace mlir {
namespace vhlo {

//===----------------------------------------------------------------------===//
// ::mlir::vhlo::XorOpV1 declarations
//===----------------------------------------------------------------------===//

namespace detail {
class XorOpV1GenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  XorOpV1GenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  XorOpV1GenericAdaptorBase(XorOpV1 op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  ::mlir::DictionaryAttr getAttributes();
};
} // namespace detail
template <typename RangeT>
class XorOpV1GenericAdaptor : public detail::XorOpV1GenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::XorOpV1GenericAdaptorBase;
public:
  XorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  XorOpV1GenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : XorOpV1GenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = XorOpV1, typename = std::enable_if_t<std::is_same_v<LateInst, XorOpV1>>>
  XorOpV1GenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getLhs() {
    return (*getODSOperands(0).begin());
  }

  ValueT getRhs() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class XorOpV1Adaptor : public XorOpV1GenericAdaptor<::mlir::ValueRange> {
public:
  using XorOpV1GenericAdaptor::XorOpV1GenericAdaptor;
  XorOpV1Adaptor(XorOpV1 op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class XorOpV1 : public ::mlir::Op<XorOpV1, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::vhlo::VersionedOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = XorOpV1Adaptor;
  template <typename RangeT>
  using GenericAdaptor = XorOpV1GenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("vhlo.xor_v1");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index);
  ::mlir::Value getLhs();
  ::mlir::Value getRhs();
  ::mlir::OpOperand &getLhsMutable();
  ::mlir::OpOperand &getRhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index);
  ::mlir::Value getResult();
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  mlir::vhlo::Version getMinVersion();
  mlir::vhlo::Version getMaxVersion();
public:
};
} // namespace vhlo
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::vhlo::XorOpV1)


#endif  // GET_OP_CLASSES

