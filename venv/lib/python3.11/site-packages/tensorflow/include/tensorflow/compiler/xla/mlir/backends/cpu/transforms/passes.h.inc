/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_CONVERTXLACPUMEMREFELEMENTCASTTOLLVMPASS
#define GEN_PASS_DECL_CONVERTXLACPUTOCPURUNTIMEPASS
#define GEN_PASS_DECL_LEGALIZEI1VECTORTRANSFEROPSPASS
#define GEN_PASS_DECL_LEGALIZELIBRARYOPSPASS
#define GEN_PASS_DECL_LEGALIZEXLAABIPASS
#define GEN_PASS_DECL_REMOVECOPIESTOOUTPARAMSPASS
#define GEN_PASS_DECL_REWRITEREALLOCTOALLOCPASS
#define GEN_PASS_DECL_SPARSECUSTOMCALLREWRITINGPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ConvertXlaCpuMemRefElementCastToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTXLACPUMEMREFELEMENTCASTTOLLVMPASS
#undef GEN_PASS_DECL_CONVERTXLACPUMEMREFELEMENTCASTTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTXLACPUMEMREFELEMENTCASTTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTXLACPUMEMREFELEMENTCASTTOLLVMPASS
namespace impl {

template <typename DerivedT>
class ConvertXlaCpuMemRefElementCastToLLVMPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertXlaCpuMemRefElementCastToLLVMPassBase;

  ConvertXlaCpuMemRefElementCastToLLVMPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertXlaCpuMemRefElementCastToLLVMPassBase(const ConvertXlaCpuMemRefElementCastToLLVMPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-convert-memref-element-cast-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-convert-memref-element-cast-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Converts xla_cpu.memref_element_cast ops to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertXlaCpuMemRefElementCastToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertXlaCpuMemRefElementCastToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertXlaCpuMemRefElementCastToLLVMPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTXLACPUMEMREFELEMENTCASTTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTXLACPUMEMREFELEMENTCASTTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertXlaCpuToCpuRuntimePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTXLACPUTOCPURUNTIMEPASS
#undef GEN_PASS_DECL_CONVERTXLACPUTOCPURUNTIMEPASS
#endif // GEN_PASS_DECL_CONVERTXLACPUTOCPURUNTIMEPASS
#ifdef GEN_PASS_DEF_CONVERTXLACPUTOCPURUNTIMEPASS
namespace impl {

template <typename DerivedT>
class ConvertXlaCpuToCpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertXlaCpuToCpuRuntimePassBase;

  ConvertXlaCpuToCpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertXlaCpuToCpuRuntimePassBase(const ConvertXlaCpuToCpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-to-cpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-to-cpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts xla_cpu operations to XLA Cpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertXlaCpuToCpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertXlaCpuToCpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertXlaCpuToCpuRuntimePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTXLACPUTOCPURUNTIMEPASS
#endif // GEN_PASS_DEF_CONVERTXLACPUTOCPURUNTIMEPASS

//===----------------------------------------------------------------------===//
// LegalizeI1VectorTransferOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEI1VECTORTRANSFEROPSPASS
#undef GEN_PASS_DECL_LEGALIZEI1VECTORTRANSFEROPSPASS
#endif // GEN_PASS_DECL_LEGALIZEI1VECTORTRANSFEROPSPASS
#ifdef GEN_PASS_DEF_LEGALIZEI1VECTORTRANSFEROPSPASS
namespace impl {

template <typename DerivedT>
class LegalizeI1VectorTransferOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeI1VectorTransferOpsPassBase;

  LegalizeI1VectorTransferOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeI1VectorTransferOpsPassBase(const LegalizeI1VectorTransferOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-i1-vector-transfers");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-i1-vector-transfers"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes transfer ops operating on vectors of i1."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeI1VectorTransferOpsPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeI1VectorTransferOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::vector::VectorDialect>();

  registry.insert<mlir::xla_cpu::XlaCpuDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeI1VectorTransferOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEI1VECTORTRANSFEROPSPASS
#endif // GEN_PASS_DEF_LEGALIZEI1VECTORTRANSFEROPSPASS

//===----------------------------------------------------------------------===//
// LegalizeLibraryOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZELIBRARYOPSPASS
#undef GEN_PASS_DECL_LEGALIZELIBRARYOPSPASS
#endif // GEN_PASS_DECL_LEGALIZELIBRARYOPSPASS
#ifdef GEN_PASS_DEF_LEGALIZELIBRARYOPSPASS
namespace impl {

template <typename DerivedT>
class LegalizeLibraryOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeLibraryOpsPassBase;

  LegalizeLibraryOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeLibraryOpsPassBase(const LegalizeLibraryOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-library-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-library-ops"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes ops that map to runtime library calls."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeLibraryOpsPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeLibraryOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::mhlo::MhloDialect>();

  registry.insert<mlir::tensor::TensorDialect>();

  registry.insert<mlir::xla_cpu::XlaCpuDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeLibraryOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZELIBRARYOPSPASS
#endif // GEN_PASS_DEF_LEGALIZELIBRARYOPSPASS

//===----------------------------------------------------------------------===//
// LegalizeXlaAbiPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEXLAABIPASS
#undef GEN_PASS_DECL_LEGALIZEXLAABIPASS
#endif // GEN_PASS_DECL_LEGALIZEXLAABIPASS
#ifdef GEN_PASS_DEF_LEGALIZEXLAABIPASS
namespace impl {

template <typename DerivedT>
class LegalizeXlaAbiPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LegalizeXlaAbiPassBase;

  LegalizeXlaAbiPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeXlaAbiPassBase(const LegalizeXlaAbiPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-abi");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-abi"; }

  ::llvm::StringRef getDescription() const override { return "Converts layouts and data formats at ABI boundaries"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeXlaAbiPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeXlaAbiPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::mhlo::MhloDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeXlaAbiPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEXLAABIPASS
#endif // GEN_PASS_DEF_LEGALIZEXLAABIPASS

//===----------------------------------------------------------------------===//
// RemoveCopiesToOutParamsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REMOVECOPIESTOOUTPARAMSPASS
#undef GEN_PASS_DECL_REMOVECOPIESTOOUTPARAMSPASS
#endif // GEN_PASS_DECL_REMOVECOPIESTOOUTPARAMSPASS
#ifdef GEN_PASS_DEF_REMOVECOPIESTOOUTPARAMSPASS
namespace impl {

template <typename DerivedT>
class RemoveCopiesToOutParamsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveCopiesToOutParamsPassBase;

  RemoveCopiesToOutParamsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveCopiesToOutParamsPassBase(const RemoveCopiesToOutParamsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-remove-copies-to-out-params");
  }
  ::llvm::StringRef getArgument() const override { return "xla-remove-copies-to-out-params"; }

  ::llvm::StringRef getDescription() const override { return "Removes redundant alloc/copy pairs to out params."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveCopiesToOutParamsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveCopiesToOutParamsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveCopiesToOutParamsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REMOVECOPIESTOOUTPARAMSPASS
#endif // GEN_PASS_DEF_REMOVECOPIESTOOUTPARAMSPASS

//===----------------------------------------------------------------------===//
// RewriteReallocToAllocPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEREALLOCTOALLOCPASS
#undef GEN_PASS_DECL_REWRITEREALLOCTOALLOCPASS
#endif // GEN_PASS_DECL_REWRITEREALLOCTOALLOCPASS
#ifdef GEN_PASS_DEF_REWRITEREALLOCTOALLOCPASS
namespace impl {

template <typename DerivedT>
class RewriteReallocToAllocPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteReallocToAllocPassBase;

  RewriteReallocToAllocPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteReallocToAllocPassBase(const RewriteReallocToAllocPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-rewrite-realloc-to-alloc");
  }
  ::llvm::StringRef getArgument() const override { return "xla-rewrite-realloc-to-alloc"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites realloc to alloc + copy"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteReallocToAllocPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteReallocToAllocPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteReallocToAllocPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEREALLOCTOALLOCPASS
#endif // GEN_PASS_DEF_REWRITEREALLOCTOALLOCPASS

//===----------------------------------------------------------------------===//
// SparseCustomCallRewritingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSECUSTOMCALLREWRITINGPASS
#undef GEN_PASS_DECL_SPARSECUSTOMCALLREWRITINGPASS
#endif // GEN_PASS_DECL_SPARSECUSTOMCALLREWRITINGPASS
#ifdef GEN_PASS_DEF_SPARSECUSTOMCALLREWRITINGPASS
namespace impl {

template <typename DerivedT>
class SparseCustomCallRewritingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SparseCustomCallRewritingPassBase;

  SparseCustomCallRewritingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseCustomCallRewritingPassBase(const SparseCustomCallRewritingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-sparse-custom-call-to-pack");
  }
  ::llvm::StringRef getArgument() const override { return "xla-sparse-custom-call-to-pack"; }

  ::llvm::StringRef getDescription() const override { return "Converts CustomCall operations to sparse operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseCustomCallRewritingPass");
  }
  ::llvm::StringRef getName() const override { return "SparseCustomCallRewritingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::sparse_tensor::SparseTensorDialect>();

  registry.insert<mlir::chlo::ChloDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseCustomCallRewritingPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSECUSTOMCALLREWRITINGPASS
#endif // GEN_PASS_DEF_SPARSECUSTOMCALLREWRITINGPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ConvertXlaCpuMemRefElementCastToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertXlaCpuMemRefElementCastToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertXlaCpuMemRefElementCastToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertXlaCpuMemRefElementCastToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertXlaCpuMemRefElementCastToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertXlaCpuToCpuRuntimePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertXlaCpuToCpuRuntimePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertXlaCpuToCpuRuntimePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertXlaCpuToCpuRuntimePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertXlaCpuToCpuRuntimePass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeI1VectorTransferOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeI1VectorTransferOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeI1VectorTransferOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeI1VectorTransferOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeI1VectorTransferOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeLibraryOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeLibraryOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeLibraryOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeLibraryOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeLibraryOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeXlaAbiPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeXlaAbiPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createXlaAbiLegalizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeXlaAbiPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createXlaAbiLegalizationPass();
  });
}

//===----------------------------------------------------------------------===//
// RemoveCopiesToOutParamsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRemoveCopiesToOutParamsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRemoveCopiesToOutParamsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRemoveCopiesToOutParamsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRemoveCopiesToOutParamsPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteReallocToAllocPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteReallocToAllocPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRewriteReallocToAllocPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteReallocToAllocPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createRewriteReallocToAllocPass();
  });
}

//===----------------------------------------------------------------------===//
// SparseCustomCallRewritingPass Registration
//===----------------------------------------------------------------------===//

inline void registerSparseCustomCallRewritingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSparseCustomCallRewritingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseCustomCallRewritingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSparseCustomCallRewritingPass();
  });
}

//===----------------------------------------------------------------------===//
// CpuTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerCpuTransformsPasses() {
  registerConvertXlaCpuMemRefElementCastToLLVMPass();
  registerConvertXlaCpuToCpuRuntimePass();
  registerLegalizeI1VectorTransferOpsPass();
  registerLegalizeLibraryOpsPass();
  registerLegalizeXlaAbiPass();
  registerRemoveCopiesToOutParamsPass();
  registerRewriteReallocToAllocPass();
  registerSparseCustomCallRewritingPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ConvertXlaCpuMemRefElementCastToLLVMPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertXlaCpuMemRefElementCastToLLVMPassBase;

  ConvertXlaCpuMemRefElementCastToLLVMPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertXlaCpuMemRefElementCastToLLVMPassBase(const ConvertXlaCpuMemRefElementCastToLLVMPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-convert-memref-element-cast-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-convert-memref-element-cast-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Converts xla_cpu.memref_element_cast ops to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertXlaCpuMemRefElementCastToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertXlaCpuMemRefElementCastToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertXlaCpuMemRefElementCastToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertXlaCpuToCpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertXlaCpuToCpuRuntimePassBase;

  ConvertXlaCpuToCpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertXlaCpuToCpuRuntimePassBase(const ConvertXlaCpuToCpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-to-cpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-to-cpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts xla_cpu operations to XLA Cpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertXlaCpuToCpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertXlaCpuToCpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertXlaCpuToCpuRuntimePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeI1VectorTransferOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeI1VectorTransferOpsPassBase;

  LegalizeI1VectorTransferOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeI1VectorTransferOpsPassBase(const LegalizeI1VectorTransferOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-i1-vector-transfers");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-i1-vector-transfers"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes transfer ops operating on vectors of i1."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeI1VectorTransferOpsPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeI1VectorTransferOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::vector::VectorDialect>();

  registry.insert<mlir::xla_cpu::XlaCpuDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeI1VectorTransferOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeLibraryOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeLibraryOpsPassBase;

  LegalizeLibraryOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeLibraryOpsPassBase(const LegalizeLibraryOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-library-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-library-ops"; }

  ::llvm::StringRef getDescription() const override { return "Legalizes ops that map to runtime library calls."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeLibraryOpsPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeLibraryOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::mhlo::MhloDialect>();

  registry.insert<mlir::tensor::TensorDialect>();

  registry.insert<mlir::xla_cpu::XlaCpuDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeLibraryOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeXlaAbiPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LegalizeXlaAbiPassBase;

  LegalizeXlaAbiPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeXlaAbiPassBase(const LegalizeXlaAbiPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-legalize-abi");
  }
  ::llvm::StringRef getArgument() const override { return "xla-legalize-abi"; }

  ::llvm::StringRef getDescription() const override { return "Converts layouts and data formats at ABI boundaries"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeXlaAbiPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeXlaAbiPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::mhlo::MhloDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeXlaAbiPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RemoveCopiesToOutParamsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveCopiesToOutParamsPassBase;

  RemoveCopiesToOutParamsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveCopiesToOutParamsPassBase(const RemoveCopiesToOutParamsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-remove-copies-to-out-params");
  }
  ::llvm::StringRef getArgument() const override { return "xla-remove-copies-to-out-params"; }

  ::llvm::StringRef getDescription() const override { return "Removes redundant alloc/copy pairs to out params."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveCopiesToOutParamsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveCopiesToOutParamsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveCopiesToOutParamsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteReallocToAllocPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteReallocToAllocPassBase;

  RewriteReallocToAllocPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteReallocToAllocPassBase(const RewriteReallocToAllocPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-rewrite-realloc-to-alloc");
  }
  ::llvm::StringRef getArgument() const override { return "xla-rewrite-realloc-to-alloc"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites realloc to alloc + copy"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteReallocToAllocPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteReallocToAllocPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteReallocToAllocPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SparseCustomCallRewritingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SparseCustomCallRewritingPassBase;

  SparseCustomCallRewritingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseCustomCallRewritingPassBase(const SparseCustomCallRewritingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-sparse-custom-call-to-pack");
  }
  ::llvm::StringRef getArgument() const override { return "xla-sparse-custom-call-to-pack"; }

  ::llvm::StringRef getDescription() const override { return "Converts CustomCall operations to sparse operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseCustomCallRewritingPass");
  }
  ::llvm::StringRef getName() const override { return "SparseCustomCallRewritingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::sparse_tensor::SparseTensorDialect>();

  registry.insert<mlir::chlo::ChloDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseCustomCallRewritingPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
